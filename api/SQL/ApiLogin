/*
NOTIFICAÇÔES
Coluna Tipo:
1 - Criação
2 - Alteração
3 - Deletar
4 - Mover
5 - Marcar
6 - Desmarcar
7 - Adicionar
8 - Sair
9 - Promover
10 - Rebaixar
11 - Remover

Coluna Tipo-Alvo:
1 - Bloco
2 - Tarefa
3 - Comentário
4 - CheckList
5 - Anexo
6 - Projeto
*/

CREATE OR REPLACE FUNCTION emailNewUser(pEmail VARCHAR(50))
  RETURNS BOOLEAN AS $$
BEGIN
  IF EXISTS(SELECT email
            FROM tb_login
            WHERE email ILIKE pEmail)
  THEN
    RETURN TRUE;
  END IF;
  RETURN FALSE;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION loginU(emailD VARCHAR, passw VARCHAR)
  RETURNS TABLE(
    id           INTEGER,
    email        VARCHAR(50),
    password     VARCHAR(20),
    username     VARCHAR(50),
    statusEmail  BOOLEAN,
    senhaCorreta BOOLEAN
  ) AS $$
BEGIN
  RETURN QUERY
  SELECT
    tb_login.id_user,
    tb_login.email,
    tb_login.username,
    tb_login.password,
    tb_login."authEmail",
    (tb_login.password = $2)
  FROM tb_login
  WHERE tb_login.email ILIKE $1 OR tb_login.username ILIKE $1;
END
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION deleteuser(usern CHARACTER VARYING)
  RETURNS BOOLEAN AS $$
BEGIN
  IF EXISTS(SELECT
              username,
              email
            FROM tb_login
            WHERE username ILIKE $1 OR email ILIKE $1)
  THEN
    DELETE FROM tb_login
    WHERE username ILIKE $1 OR email ILIKE $1;
    RETURN TRUE;
  END IF;
  RETURN FALSE;
END
$$
LANGUAGE plpgsql;

--SELECT * FROM deleteuser('joao1');

--SELECT * FROM returnDataUser(700)

CREATE OR REPLACE FUNCTION returnDataUser(pIdUser INTEGER)
  RETURNS TABLE(
    username VARCHAR(50),
    email    VARCHAR(100)
  ) AS $$
BEGIN
  RETURN QUERY
  SELECT
    tl.username,
    tl.email
  FROM tb_login tl
  WHERE tl.id_user = pIdUser;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION changeUsername(pNewUsername CHARACTER VARYING, pOldUsername CHARACTER VARYING)
  RETURNS BOOLEAN AS $$
BEGIN

  IF NOT EXISTS(SELECT username
                FROM tb_login
                WHERE username ILIKE pNewUsername)
  THEN
    UPDATE tb_login
    SET username = pNewUsername
    WHERE username = pOldUsername;
    RETURN TRUE;
  END IF;
  RETURN FALSE;
END
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION changeEmail(pNewEmail CHARACTER VARYING, pOldEmail CHARACTER VARYING)
  RETURNS BOOLEAN AS $$
BEGIN

  IF NOT EXISTS(SELECT email
                FROM tb_login
                WHERE email ILIKE pNewEmail)
  THEN
    UPDATE tb_login
    SET email = pNewEmail
    WHERE email = pOldEmail;
    RETURN TRUE;
  END IF;
  RETURN FALSE;
END
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION changeName(pNewName CHARACTER VARYING, pUsername CHARACTER VARYING)
  RETURNS BOOLEAN AS $$
BEGIN

  UPDATE tb_login
  SET name = pNewName
  WHERE username = pUsername;
  RETURN TRUE;

END
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION changepass(usern CHARACTER VARYING, oldpass CHARACTER VARYING, newpass CHARACTER VARYING)
  RETURNS BOOLEAN AS $$
BEGIN
  IF EXISTS(SELECT
              username,
              password
            FROM tb_login
            WHERE (username ILIKE $1 OR email ILIKE $1) AND password = $2)
  THEN
    UPDATE tb_login
    SET password = $3
    WHERE username ILIKE $1 OR email ILIKE $1;
    RETURN TRUE;
  END IF;
  RETURN FALSE;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION forgotPass(pUsern CHARACTER VARYING, pNewPass CHARACTER VARYING)
  RETURNS BOOLEAN AS $$
BEGIN
  IF EXISTS(SELECT *
            FROM tb_login
            WHERE username ILIKE pUsern OR email ILIKE pUsern)
  THEN
    UPDATE tb_login
    SET password = pNewPass
    WHERE username ILIKE pUsern OR email ILIKE pUsern;
  END IF;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION newuser(emailD CHARACTER VARYING, passw CHARACTER VARYING, img CHARACTER VARYING,
                                   nameP  CHARACTER VARYING, usern CHARACTER VARYING)
  RETURNS TABLE(
    idNewUser INTEGER
  )
LANGUAGE plpgsql
AS $$
DECLARE
  vIdNewUser INTEGER;
BEGIN
  IF NOT exists(SELECT *
                FROM tb_login
                WHERE emailD = tb_login.email OR usern = tb_login.username)
  THEN
    INSERT INTO tb_login (email, password, profile_img, name, username) VALUES ($1, $2, $3, $4, $5)
    RETURNING id_user
      INTO vIdNewUser;
    RETURN QUERY
    SELECT vIdNewUser;
  ELSE
    RETURN QUERY
    SELECT 0;
  END IF;
END
$$;

CREATE OR REPLACE FUNCTION consult()
  RETURNS TABLE(
    email     VARCHAR(50),
    username  VARCHAR(50),
    password  VARCHAR(20),
    img       VARCHAR(50),
    name      VARCHAR(50),
    emailAuth BOOLEAN
  ) AS $$
BEGIN
  RETURN QUERY
  SELECT
    tb_login.email,
    tb_login.username,
    tb_login.password,
    tb_login.profile_img,
    tb_login.name,
    tb_login."authEmail"
  FROM tb_login;
END
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION verify_email(usern CHARACTER VARYING)
  RETURNS TABLE(

    statusEmail BOOLEAN
  )
AS $$
BEGIN
  IF EXISTS(SELECT "authEmail"
            FROM tb_login l
            WHERE l.username ILIKE $1)
  THEN
    RETURN QUERY
    SELECT "authEmail"
    FROM tb_login l
    WHERE l.username ILIKE $1;
  END IF;
END
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION verify_img(imgPath CHARACTER VARYING, usern CHARACTER VARYING)
  RETURNS BOOLEAN
AS $$
BEGIN
  IF EXISTS(SELECT
              profile_img,
              username,
              email
            FROM tb_login l
            WHERE l.email = usern OR l.username = usern)
  THEN
    UPDATE tb_login l
    SET profile_img = imgPath
    WHERE l.email ILIKE usern OR l.username ILIKE usern;
    RETURN TRUE;
  ELSE
    RETURN FALSE;
  END IF;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION verify_imgproject(imgPath CHARACTER VARYING, usern INTEGER)
  RETURNS BOOLEAN
AS $$
BEGIN
  IF EXISTS(SELECT
              img_project,
              name_project
            FROM tb_projects
            WHERE tb_projects.id_project = usern)
  THEN
    UPDATE tb_projects
    SET img_project = imgPath
    WHERE tb_projects.id_project = usern;
    RETURN TRUE;
  ELSE
    RETURN FALSE;
  END IF;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION imgDb(usern CHARACTER VARYING)
  RETURNS TABLE(
    currentImg VARCHAR(50)
  ) AS $$
BEGIN
  IF EXISTS(SELECT
              l.username,
              l.profile_img
            FROM tb_login l
            WHERE l.username ILIKE $1)
  THEN

  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION removeImg(pIdUser INTEGER)
  RETURNS TABLE(
    path VARCHAR(50)
  ) AS $$
DECLARE
  vPath VARCHAR(50);
BEGIN
  IF EXISTS(SELECT *
            FROM tb_login
            WHERE id_user = pIdUser AND profile_img <> '/imgsUser/default.png')
  THEN
    SELECT profile_img
    INTO vPath
    FROM tb_login
    WHERE id_user = pIdUser;

    UPDATE tb_login
    SET profile_img = '/imgsUser/default.png'
    WHERE id_user = pIdUser;

    RETURN QUERY
    SELECT vPath;
  END IF;
END;
$$
LANGUAGE plpgsql;

--SELECT * FROM verify_img('/default.png','joaoo');

--UPDATE tb_login SET profile_img = '/default.png'

--SELECT * FROM verify_email('joao1559');

CREATE OR REPLACE FUNCTION consultuser(usern VARCHAR)
  RETURNS TABLE(
    id_user    INTEGER,
    email      VARCHAR(50),
    username   VARCHAR(50),
    PASSWORD   VARCHAR(20),
    img        VARCHAR(50),
    NAME       VARCHAR(50),
    statusAuth BOOLEAN
  ) AS $$
BEGIN
  RETURN QUERY
  SELECT
    tb_login.id_user,
    tb_login.email,
    tb_login.username,
    tb_login.password,
    tb_login.profile_img,
    tb_login.name,
    tb_login."authEmail"
  FROM tb_login
  WHERE tb_login.username ILIKE $1 OR tb_login.email ILIKE $1;
END
$$
LANGUAGE plpgsql;

--SELECT * FROM consultuser('joao@joao.com')

CREATE OR REPLACE FUNCTION verify_token(usern CHARACTER VARYING)
  RETURNS TABLE(
    userA  VARCHAR(50),
    status TEXT
  )
LANGUAGE plpgsql
AS $$
BEGIN
  IF EXISTS(SELECT
              l.username,
              l.email
            FROM tb_login l
            WHERE l.username ILIKE $1 OR l.email ILIKE $1 AND "authEmail" = FALSE)
  THEN
    UPDATE tb_login l
    SET "authEmail" = TRUE
    WHERE l.username ILIKE $1 OR l.email ILIKE $1;
    RETURN QUERY
    SELECT
      $1,
      'Autenticado com sucesso' :: TEXT;
  END IF;
  IF EXISTS(SELECT
              l.username,
              l.email
            FROM tb_login l
            WHERE l.username ILIKE $1 OR l.email ILIKE $1 AND "authEmail" = TRUE)
  THEN
    RETURN QUERY
    SELECT
      $1,
      'Já autenticado' :: TEXT;
  END IF;
END
$$;

--SELECT * FROM verify_token('A@A.com');

CREATE OR REPLACE FUNCTION passwordToEmail(usern CHARACTER VARYING)
  RETURNS TABLE(
    passwordR VARCHAR(20),
    nameuser  VARCHAR(50)
  ) AS $$
BEGIN
  IF EXISTS(SELECT
              l.username,
              l.email,
              l.password
            FROM tb_login l
            WHERE l.username ILIKE usern OR l.email ILIKE usern)
  THEN
    RETURN QUERY
    SELECT
      l.username,
      l.password,
      l.name
    FROM tb_login l
    WHERE l.username ILIKE usern OR l.email ILIKE usern;
  END IF;
END;
$$
LANGUAGE plpgsql;

--SELECT * FROM passwordToEmail('joao.vitor@smn.com.br');

CREATE OR REPLACE FUNCTION emailexists(emailuser CHARACTER VARYING)
  RETURNS TABLE(
    usern  VARCHAR(50),
    emailu VARCHAR(50),
    passw  VARCHAR(50)
  ) AS $$
BEGIN
  IF EXISTS(SELECT l.email
            FROM tb_login l
            WHERE l.email ILIKE $1)
  THEN
    RETURN QUERY
    SELECT
      l.username,
      l.email,
      l.password
    FROM tb_login l
    WHERE l.email ILIKE $1;
  END IF;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION relogin(usernameD CHARACTER VARYING)
  RETURNS TABLE(
    usern VARCHAR(50),
    passw VARCHAR(50)
  ) AS $$
BEGIN
  IF EXISTS(SELECT
              l.username,
              l.email
            FROM tb_login l
            WHERE l.username ILIKE $1 OR l.email ILIKE $1)
  THEN
    RETURN QUERY
    SELECT
      l.username,
      l.password
    FROM tb_login l
    WHERE l.username ILIKE $1 OR l.email ILIKE $1;
  END IF;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION newproject(nameProject CHARACTER VARYING, idDono INTEGER, descricao CHARACTER VARYING,
                                      imgProject  CHARACTER VARYING)
  RETURNS TABLE(
    idproject INTEGER
  ) AS $$
DECLARE
  idprojectR INTEGER;
BEGIN
  IF EXISTS(SELECT l.id_user
            FROM tb_login l
            WHERE l.id_user = idDono)
  THEN
    INSERT INTO tb_projects (name_project, id_user_owner, description, img_project) VALUES ($1, $2, $3, $4)
    RETURNING id_project
      INTO idprojectR;
    INSERT INTO tb_notifications (id_user, id_project, type) VALUES (idDono, idprojectR, 1);
    RETURN QUERY
    SELECT idprojectR;
  END IF;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION insertTeamNewProject(pTeam JSON)
  RETURNS BOOLEAN AS $$
BEGIN
  INSERT INTO tb_team (id_project, id_user, permissions)
    SELECT
      idProject,
      idUser,
      permission
    FROM json_to_recordset(pTeam)
      AS x(
         idProject INTEGER,
         idUser INTEGER,
         permission BOOLEAN
         )
  RETURNING TRUE;
END;
$$
LANGUAGE plpgsql;

--SELECT * FROM getproject(25);

CREATE OR REPLACE FUNCTION getproject(usern INTEGER)
  RETURNS TABLE(
    id_project INTEGER,
    namep      VARCHAR(50),
    descrip    TEXT,
    img        VARCHAR(50),
    permission BOOLEAN
  ) AS $$
BEGIN
  RETURN QUERY
  SELECT
    tp.id_project,
    name_project,
    description,
    img_project,
    (SELECT permissions
     FROM tb_team tt
     WHERE id_user = usern AND tt.id_project = tp.id_project)
  FROM tb_projects tp
  WHERE tp.id_project IN (SELECT tb_team.id_project
                          FROM tb_team
                          WHERE usern = id_user) AND active <> FALSE;
END;
$$
LANGUAGE plpgsql;

--SELECT * FROM getprojectsearch(73,25);

CREATE OR REPLACE FUNCTION getprojectsearch(idpro INTEGER, iduser INTEGER)
  RETURNS TABLE(
    namep                VARCHAR(50),
    descrip              TEXT,
    img                  VARCHAR(50),
    loggedUserPermission BOOLEAN,
    team                 JSON
  ) AS $$
BEGIN
  IF EXISTS(SELECT id_project
            FROM tb_team
            WHERE id_project = $1 AND id_user = $2)
  THEN
    RETURN QUERY
    SELECT
      name_project,
      description,
      img_project,
      (SELECT permissions
       FROM tb_team
       WHERE id_project = idpro AND id_user = iduser),
      (
        SELECT COALESCE(json_agg(teamJson), '[]')
        FROM (SELECT
                tb_team.id_user,
                name,
                profile_img,
                email,
                username,
                permissions
              FROM tb_team
                INNER JOIN tb_login ON tb_login.id_user = tb_team.id_user
              WHERE id_project = idpro
              ORDER BY permissions DESC) AS teamJson
      ) teams
    FROM tb_projects

    WHERE tb_projects.id_project = idpro;
  END IF;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION changeproject(idproj INTEGER, namep CHARACTER VARYING, descrip CHARACTER VARYING,
                                         imgp   CHARACTER VARYING, permission BOOLEAN, idUser INTEGER)
  RETURNS TABLE(
    idprojectR INTEGER
  ) AS $$
DECLARE
  vOldName VARCHAR(100);
BEGIN
  IF permission <> FALSE AND
     EXISTS(SELECT *
            FROM tb_projects
            WHERE id_project = idproj)
  THEN

    SELECT name_project
    INTO vOldName
    FROM tb_projects
    WHERE id_project = idproj;

    UPDATE tb_projects
    SET
      name_project = namep,
      description  = descrip,
      img_project  = imgp,
      active       = TRUE
    WHERE id_project = idproj;

    IF ((SELECT name_project
         FROM tb_projects
         WHERE id_project = idproj) <> vOldName)
    THEN

      INSERT INTO tb_notifications (id_user, type, target_type, id_project, old_name, new_name)
      VALUES (idUser, 2, 6, idproj, vOldName, (SELECT name_project
                                               FROM tb_projects
                                               WHERE id_project = idproj));

      UPDATE tb_team
      SET notifications = TRUE
      WHERE id_project = idproj AND id_user <> idUser;
    ELSE
      INSERT INTO tb_notifications (id_user, type, target_type, id_project)
      VALUES (idUser, 2, 6, idproj);

      UPDATE tb_team
      SET notifications = TRUE
      WHERE id_project = idproj AND id_user <> idUser;

    END IF;

    RETURN QUERY
    SELECT idproj;
  END IF;
  RETURN QUERY
  SELECT 0;
END;
$$
LANGUAGE plpgsql;

--SELECT * FROM deactivateProject(99,25);

CREATE OR REPLACE FUNCTION deactivateProject(idproject INTEGER, idUser INTEGER)
  RETURNS BOOLEAN AS $$
DECLARE
  vPermission BOOLEAN;
BEGIN
  IF EXISTS(SELECT *
            FROM tb_projects
            WHERE id_project = idproject AND active = TRUE)
  THEN
    SELECT permissions
    INTO vPermission
    FROM tb_team
    WHERE id_project = idproject AND id_user = idUser;

    IF vPermission = TRUE
    THEN
      UPDATE tb_projects
      SET active = FALSE
      WHERE id_project = idproject;
      RETURN TRUE;
    END IF;
    RETURN FALSE;
  END IF;
  RETURN FALSE;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION getPathImg(pIdProject INTEGER)
  RETURNS TABLE(
    path VARCHAR(20)
  ) AS $$
BEGIN
  RETURN QUERY
  SELECT img_project
  FROM tb_projects
  WHERE id_project = pIdProject;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION timeproject(pIdProject INTEGER, pIdUser INTEGER, permission BOOLEAN, pIdAdmin INTEGER)
  RETURNS BOOLEAN AS $$
BEGIN
  IF EXISTS(SELECT *
            FROM tb_team
            WHERE id_user = pIdAdmin AND id_project = pIdProject AND permissions = TRUE)
  THEN
    INSERT
    INTO tb_team (id_project, id_user, permissions) VALUES (pIdProject, pIdUser, permission);

    INSERT INTO tb_notifications (id_user, type, id_new_user, target_type, id_project)
    VALUES (pIdAdmin, 7, pIdUser, 6, pIdProject);

    UPDATE tb_team
    SET notifications = TRUE
    WHERE id_project = pIdProject AND id_user <> pIdAdmin;

    RETURN TRUE;
  END IF;
  RETURN FALSE;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION insertOwner(pIdProject INTEGER, pIdUser INTEGER, permission BOOLEAN)
  RETURNS BOOLEAN AS $$
BEGIN
  IF EXISTS(SELECT *
            FROM tb_projects
            WHERE id_project = pIdProject)
  THEN
    INSERT
    INTO tb_team (id_project, id_user, permissions) VALUES (pIdProject, pIdUser, permission);
    RETURN TRUE;
  END IF;
  RETURN FALSE;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION verify_permission(idproj INTEGER, iduser INTEGER)
  RETURNS TABLE(
    idproject  INTEGER,
    iduserR    INTEGER,
    permission BOOLEAN
  ) AS $$
BEGIN
  IF EXISTS(SELECT *
            FROM tb_team
            WHERE idproj = id_project AND iduser = id_user)
  THEN
    RETURN QUERY
    SELECT
      id_project,
      id_user,
      permissions
    FROM tb_team
    WHERE idproj = id_project AND iduser = id_user;
  END IF;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION exitProject(pIdUser INTEGER, pIdProject INTEGER)
  RETURNS TABLE(
    status INTEGER
  ) AS $$
DECLARE
  vQntdAdmins  INTEGER;
  vQntdMembers INTEGER;
  vArrayBlocks INTEGER [];
  vArrayTasks  INTEGER [];
BEGIN

  IF EXISTS(SELECT *
            FROM tb_team
            WHERE id_user = pIdUser AND id_project = pIdProject AND permissions = FALSE)
  THEN

    DELETE FROM tb_team
    WHERE id_user = pIdUser AND id_project = pIdProject;

    INSERT INTO tb_notifications (id_user, type, target_type, id_project)
    VALUES (pIdUser, 8, 6, pIdProject);

    UPDATE tb_team
    SET notifications = TRUE
    WHERE id_project = pIdProject AND id_user <> pIdUser;

    RETURN QUERY
    SELECT 1;
  END IF;

  SELECT COUNT(id_user)
  OVER (
    PARTITION BY 1 )
  INTO vQntdAdmins
  FROM tb_team
  WHERE id_project = pIdProject
        AND permissions
  LIMIT 1;

  SELECT COUNT(id_user)
  OVER (
    PARTITION BY 1 )
  INTO vQntdMembers
  FROM tb_team
  WHERE id_project = pIdProject
        AND permissions = FALSE
  LIMIT 1;

  IF vQntdAdmins > 1
  THEN

    DELETE FROM tb_team
    WHERE id_user = pIdUser AND id_project = pIdProject;

    INSERT INTO tb_notifications (id_user, type, target_type, id_project)
    VALUES (pIdUser, 8, 6, pIdProject);

    vArrayBlocks := ARRAY(SELECT id_blocks
                          FROM tb_blocks
                          WHERE project_owner = pIdProject);

    vArrayTasks := ARRAY(SELECT id_task
                         FROM tb_tasks
                         WHERE id_block = ANY (vArrayBlocks));

    DELETE FROM tb_team_tasks
    WHERE id_user = pIdUser AND id_task = ANY (vArrayTasks);

    RETURN QUERY
    SELECT 2;
  ELSEIF vQntdAdmins > 1 AND vQntdMembers > 0
    THEN
      RETURN QUERY
      SELECT 3;
  ELSEIF vQntdAdmins = 1 AND vQntdMembers = 0
    THEN
      EXECUTE deactivateProject(pIdProject, pIdUser);
      RETURN QUERY
      SELECT 4;
  END IF;
  RETURN QUERY
  SELECT 0;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION removeUsersTeam(idproj     INTEGER, idusert INTEGER, permission BOOLEAN,
                                           iduseralvo INTEGER)
  RETURNS TABLE(
    statusCode INTEGER
  ) AS $$
DECLARE
  vStatus INTEGER;
BEGIN
  IF permission <> FALSE
  THEN
    IF EXISTS(SELECT *
              FROM tb_team
              WHERE idproj = id_project AND id_user = idusert)
       AND EXISTS(SELECT *
                  FROM tb_team
                  WHERE idproj = id_project AND
                        iduseralvo = id_user)
    THEN
      DELETE FROM tb_team
      WHERE idproj = id_project AND
            id_user = iduseralvo
      RETURNING 200
        INTO
          vStatus;

      INSERT INTO tb_notifications (id_user, type, id_new_user, target_type)
      VALUES (idusert, 11, iduseralvo, 6);

      UPDATE tb_team
      SET notifications = TRUE
      WHERE id_project = idproj AND id_user <> idusert;

      RETURN QUERY
      SELECT vStatus;
    ELSE
      RETURN QUERY
      SELECT 404;
    END IF;
  ELSE
    RETURN QUERY
    SELECT 401;
  END IF;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION changePermissionMember(pIdProject INTEGER, pIdUserTarget INTEGER, permission BOOLEAN,
                                                  pIdUser    INTEGER)
  RETURNS TABLE(
    status INTEGER
  ) AS $$
DECLARE
  vOldPermission BOOLEAN;
BEGIN
  IF EXISTS(SELECT *
            FROM tb_team
            WHERE id_project = pIdProject AND
                  id_user = pIdUserTarget) AND permission = TRUE
  THEN

    SELECT permissions
    INTO vOldPermission
    FROM tb_team
    WHERE id_project = pIdProject AND
          id_user = pIdUserTarget;

    UPDATE tb_team
    SET permissions = NOT permissions
    WHERE id_project = pIdProject AND
          id_user = pIdUserTarget;

    IF vOldPermission = TRUE
    THEN

      INSERT INTO tb_notifications (id_user, id_new_user, type, target_type, id_project)
      VALUES (pIdUser, pIdUserTarget, 10, 6, pIdProject);

      UPDATE tb_team
      SET notifications = TRUE
      WHERE id_project = pIdProject AND id_user <> pIdUser;

    ELSE

      INSERT INTO tb_notifications (id_user, id_new_user, type, target_type, id_project)
      VALUES (pIdUser, pIdUserTarget, 9, 6, pIdProject);

      UPDATE tb_team
      SET notifications = TRUE
      WHERE id_project = pIdProject AND id_user <> pIdUser;

    END IF;

    RETURN QUERY
    SELECT 1;
  END IF;
  RETURN QUERY
  SELECT 0;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION defaultBlocks(pIdProject INTEGER)
  RETURNS BOOLEAN AS $$
BEGIN
  IF EXISTS(SELECT id_project
            FROM tb_projects
            WHERE id_project = pIdProject)
  THEN
    INSERT INTO tb_blocks (name_blocks, project_owner)
    VALUES ('A fazer', pIdProject),
      ('Fazendo', pIdProject),
      ('Concluído', pIdProject);
    RETURN TRUE;
  END IF;
  RETURN FALSE;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION newblocks(nameq CHARACTER VARYING, idproj INTEGER, idUser INTEGER)
  RETURNS BOOLEAN AS $$
DECLARE
  vIdBlock INTEGER;
BEGIN
  IF EXISTS(SELECT *
            FROM tb_projects
            WHERE id_project = idproj)
  THEN
    INSERT INTO tb_blocks (name_blocks, project_owner) VALUES (nameq, idproj)
    RETURNING id_blocks
      INTO vIdBlock;

    INSERT INTO tb_notifications (id_block, id_user, id_project, new_name, type, target_type)
    VALUES (vIdBlock, idUser, idproj, nameq, 1, 1);

    UPDATE tb_team
    SET notifications = TRUE
    WHERE id_project = idproj AND id_user <> idUser;
    RETURN TRUE;
  END IF;
  RETURN FALSE;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION changeBlockName(pNewName CHARACTER VARYING, pIdBlock INTEGER, pIdUser INTEGER)
  RETURNS BOOLEAN AS $$
DECLARE
  oldName VARCHAR(50);
BEGIN
  IF EXISTS(SELECT *
            FROM tb_blocks
            WHERE id_blocks = pIdBlock)
  THEN
    SELECT name_blocks
    INTO oldName
    FROM tb_blocks
    WHERE id_blocks = pIdBlock;

    IF (pNewName <> oldName)
    THEN

      UPDATE tb_blocks
      SET name_blocks = pNewName
      WHERE id_blocks = pIdBlock;


      INSERT INTO tb_notifications (id_user, id_block, type, old_name, new_name, id_project, target_type)
      VALUES (pIdUser, pIdBlock, 2, oldName, (SELECT name_blocks
                                              FROM tb_blocks
                                              WHERE id_blocks = pIdBlock), (SELECT project_owner
                                                                            FROM tb_blocks
                                                                            WHERE id_blocks = pIdBlock), 1);

      UPDATE tb_team
      SET notifications = TRUE
      WHERE id_project = (SELECT project_owner
                          FROM tb_blocks
                          WHERE id_blocks = pIdBlock) AND id_user <> pIdUser;
      RETURN TRUE;
    END IF;
  END IF;
  RETURN FALSE;
END;
$$
LANGUAGE plpgsql;

--INSERT INTO tb_team(id_project,id_user,permissions)values(73,31,2),(73,32,2);

--SELECT * FROM searchblock(73)

CREATE OR REPLACE FUNCTION searchblock(projectOwner INTEGER)
  RETURNS TABLE(
    idBlock   INTEGER,
    nameBlock VARCHAR(50),
    tasks     JSON
  ) AS $$
DECLARE
  vIdBlocks INTEGER [];
BEGIN

  vIdBlocks := ARRAY(SELECT id_blocks
                     FROM tb_blocks
                     WHERE project_owner = projectOwner);

  IF vIdBlocks IS NOT NULL
  THEN
    RETURN QUERY
    SELECT
      tb.id_blocks,
      tb.name_blocks,
      (SELECT COALESCE(json_agg(TasksJson), '[]')
       FROM (SELECT
               tt.id_task,
               tt.name_task,
               tt.final_date,
               tt.position,
               (SELECT count(id_attachment)
                FROM tb_attachment ta
                WHERE tt.id_task = ta.id_task)                 AS attachments,

               (SELECT count(id_comment)
                FROM tb_comments tc
                WHERE tt.id_task = tc.id_task)                 AS comments,

               (SELECT coalesce(json_agg(teamTask), '[]')
                FROM (SELECT
                        tb_team_tasks.id_user,
                        tb_team_tasks.id_team_task,
                        tb_login.name,
                        tb_login.profile_img,
                        tb_login.email
                      FROM tb_team_tasks
                        INNER JOIN tb_login ON tb_team_tasks.id_user = tb_login.id_user
                      WHERE id_task = tt.id_task) AS teamTask) AS teamTask
             FROM tb_tasks tt
             WHERE tt.id_block = tb.id_blocks
             ORDER BY position ASC) AS TasksJson
      ) tasks
    FROM tb_blocks tb
    WHERE tb.id_blocks = ANY (vIdBlocks)
    ORDER BY id_blocks ASC;
  END IF;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION deleteBlock(pIdBlock INTEGER, pIdUser INTEGER)
  RETURNS BOOLEAN AS $$
BEGIN
  IF EXISTS(SELECT *
            FROM tb_blocks
            WHERE id_blocks = pIdBlock)
  THEN
    DELETE FROM tb_tasks
    WHERE id_block = pIdBlock;

    INSERT INTO tb_notifications (id_project, type, id_user, old_name, target_type)
    VALUES ((SELECT project_owner
             FROM tb_blocks
             WHERE id_blocks = pIdBlock), 3, pIdUser, (SELECT name_blocks
                                                       FROM tb_blocks
                                                       WHERE id_blocks = pIdBlock), 1);

    UPDATE tb_team
    SET notifications = TRUE
    WHERE id_project = (SELECT project_owner
                        FROM tb_blocks
                        WHERE id_blocks = pIdBlock) AND id_user <> pIdUser;

    DELETE FROM tb_notifications
    WHERE id_block = pIdBlock;

    DELETE FROM tb_blocks
    WHERE id_blocks = pIdBlock;
    RETURN TRUE;

  END IF;
  RETURN FALSE;
END;
$$
LANGUAGE plpgsql;

--SELECT * FROM newtasks('joao','21/09/2017',2)

--SELECT * FROM getLastPosition(69)

CREATE OR REPLACE FUNCTION getLastPosition(pIdBlock INTEGER)
  RETURNS TABLE(
    "position" INTEGER
  ) AS $$
DECLARE
  vLastPosition INTEGER := -1;
BEGIN
  IF EXISTS(SELECT *
            FROM tb_blocks
            WHERE id_blocks = pIdBlock)
  THEN

    IF (SELECT l.position
        FROM tb_tasks l
        WHERE l.position > vLastPosition AND l.id_block = pIdBlock
        ORDER BY l.position DESC
        LIMIT 1) IS NOT NULL
    THEN

      SELECT l.position
      INTO vLastPosition
      FROM tb_tasks l
      WHERE l.position > vLastPosition AND l.id_block = pIdBlock
      ORDER BY l.position DESC
      LIMIT 1;
    END IF;
    RETURN QUERY
    SELECT (vLastPosition + 1);
  END IF;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION newtasks(nametask  CHARACTER VARYING,
                                    date      TIMESTAMP,
                                    descrip   TEXT,
                                    idblock   INTEGER,
                                    pPosition INTEGER,
                                    pIdUser   INTEGER)
  RETURNS TABLE(
    idTask       INTEGER,
    nameTaskR    VARCHAR(100),
    dateR        TIMESTAMP,
    rDescription TEXT,
    idBlockOwner INTEGER,
    rPosition    INTEGER
  ) AS $$
DECLARE
  vIdTask     INTEGER;
  vNameTask   VARCHAR(100);
  vDate       TIMESTAMP;
  vDescript   TEXT;
  vBlockOwner INTEGER;
  vPosition   INTEGER;

BEGIN
  IF EXISTS(SELECT *
            FROM tb_blocks
            WHERE id_blocks = idblock)
  THEN
    INSERT INTO tb_tasks (name_task, final_date, description, id_block, position)
    VALUES (nametask, date, descrip, idblock, pPosition)
    RETURNING id_task, name_task, final_date, description, id_block, position
      INTO vIdTask, vNameTask, vDate, vDescript, vBlockOwner, vPosition;

    INSERT INTO tb_notifications (id_user, id_block, id_project, id_task, type, new_name, target_type)
    VALUES (pIdUser, idblock, (SELECT project_owner
                               FROM tb_blocks
                               WHERE id_blocks = idblock), vIdTask, 1, vNameTask, 2);

    UPDATE tb_team
    SET notifications = TRUE
    WHERE id_project = (SELECT project_owner
                        FROM tb_blocks
                        WHERE id_blocks = idblock) AND id_user <> pIdUser;

    RETURN QUERY
    SELECT
      vIdTask,
      vNameTask,
      vDate,
      vDescript,
      vBlockOwner,
      vPosition;
  END IF;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION changeTask(pIdTask INTEGER, pNameTask CHARACTER VARYING, pDate TIMESTAMP, pDescription TEXT,
                                      pIdUser INTEGER)
  RETURNS BOOLEAN AS $$
DECLARE
  vOldName VARCHAR(100);
BEGIN
  IF EXISTS(SELECT *
            FROM tb_tasks
            WHERE id_task = pIdTask)
  THEN
    SELECT name_task
    INTO vOldName
    FROM tb_tasks
    WHERE id_task = pIdTask;

    UPDATE tb_tasks
    SET name_task = pNameTask,
      final_date  = pDate,
      description = pDescription
    WHERE id_task = pIdTask;

    IF vOldName = (SELECT name_task
                   FROM tb_tasks
                   WHERE id_task = pIdTask)
    THEN
      INSERT INTO tb_notifications (id_task, type, id_user, target_type, id_block, id_project)
      VALUES (pIdTask,
              2,
              pIdUser, 2, (SELECT id_block
                           FROM tb_tasks
                           WHERE id_task = pIdTask), (SELECT project_owner
                                                      FROM tb_blocks
                                                      WHERE id_blocks = (SELECT id_block
                                                                         FROM tb_tasks
                                                                         WHERE id_task = pIdTask)));

      UPDATE tb_team
      SET notifications = TRUE
      WHERE id_project = (SELECT project_owner
                          FROM tb_blocks
                          WHERE id_blocks = (SELECT id_block
                                             FROM tb_tasks
                                             WHERE id_task = pIdTask)) AND id_user <> pIdUser;

    ELSE
      INSERT INTO tb_notifications (id_task, type, id_user, old_name, new_name, target_type, id_block, id_project)
      VALUES (pIdTask,
              2,
              pIdUser,
              vOldName,
              (SELECT name_task
               FROM tb_tasks
               WHERE tb_tasks.id_task = pIdTask),
              2,
              (SELECT id_block
               FROM tb_tasks
               WHERE id_task = pIdTask),
              (SELECT project_owner
               FROM tb_blocks
               WHERE id_blocks = (SELECT id_block
                                  FROM tb_tasks
                                  WHERE id_task = pIdTask)));

      UPDATE tb_team
      SET notifications = TRUE
      WHERE id_project = (SELECT project_owner
                          FROM tb_blocks
                          WHERE id_blocks = (SELECT id_block
                                             FROM tb_tasks
                                             WHERE id_task = pIdTask)) AND id_user <> pIdUser;

    END IF;
    RETURN TRUE;

  END IF;
  RETURN FALSE;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION moveTask(pIdTask INTEGER, pIdBlock INTEGER, pIdUser INTEGER)
  RETURNS BOOLEAN AS $$
DECLARE
  vOldBlock INTEGER;
BEGIN
  IF EXISTS(SELECT *
            FROM tb_tasks
            WHERE id_task = pIdTask) AND EXISTS(SELECT *
                                                FROM tb_blocks
                                                WHERE id_blocks = pIdBlock)
  THEN
    SELECT id_block
    INTO vOldBlock
    FROM tb_tasks
    WHERE id_task = pIdTask;

    UPDATE tb_tasks
    SET id_block = pIdBlock
    WHERE id_task = pIdTask;

    INSERT INTO tb_notifications (id_user, id_block, id_block_final, id_task, type, target_type, id_project)
    VALUES (pIdUser, vOldBlock, pIdBlock, pIdTask, 4, 2, (SELECT project_owner
                                                          FROM tb_blocks
                                                          WHERE id_blocks = vOldBlock));

    UPDATE tb_team
    SET notifications = TRUE
    WHERE id_project = (SELECT project_owner
                        FROM tb_blocks
                        WHERE id_blocks = vOldBlock) AND id_user <> pIdUser;
    RETURN TRUE;
  END IF;
  RETURN FALSE;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION showContentTask(pIdTask INTEGER)
  RETURNS TABLE(
    nameTask    VARCHAR(50),
    finalDate   TIMESTAMP,
    description TEXT,
    team        JSON,
    comments    JSON,
    checklists  JSON,
    attachment  JSON
  ) AS $$
BEGIN
  IF EXISTS(SELECT *
            FROM tb_tasks
            WHERE id_task = pIdTask)
  THEN
    RETURN QUERY
    SELECT
      l.name_task,
      l.final_date,
      l.description,
      (SELECT coalesce(json_agg(teamTask), '[]')
       FROM (SELECT
               tb_team_tasks.id_user,
               tb_team_tasks.id_team_task,
               tb_login.name,
               tb_login.profile_img,
               tb_login.email
             FROM tb_team_tasks
               INNER JOIN tb_login ON tb_team_tasks.id_user = tb_login.id_user
             WHERE id_task = pIdTask) AS teamTask),

      (SELECT coalesce(json_agg(jsonComments), '[]')
       FROM (SELECT
               l.id_comment,
               l.comment
             FROM tb_comments l
             WHERE l.id_task = pIdTask) AS jsonComments),

      (SELECT coalesce(json_agg(jsonChecklist), '[]')
       FROM (SELECT
               id_checklist,
               name_checklist,
               checked
             FROM tb_checklist_tasks
             WHERE id_task = pIdTask) AS jsonChecklist),
      (SELECT coalesce(json_agg(jsonAttachment), '[]')
       FROM (SELECT
               id_attachment,
               file_name,
               size,
               path
             FROM tb_attachment
             WHERE id_task = pIdTask) AS jsonAttachment)
    FROM tb_tasks l
    WHERE l.id_task = pIdTask;

  END IF;
END;
$$
LANGUAGE plpgsql;

--SELECT * FROM deleteTask(78)

CREATE OR REPLACE FUNCTION deleteTask(pIdTask INTEGER, pIdUser INTEGER)
  RETURNS BOOLEAN AS $$
DECLARE
  vNameTask  VARCHAR(100);
  vIdBlock   INTEGER;
  vIdProject INTEGER;
BEGIN
  IF EXISTS(SELECT *
            FROM tb_tasks
            WHERE id_task = pIdTask)
  THEN
    DELETE FROM tb_notifications
    WHERE id_task = pIdTask;

    DELETE FROM tb_comments
    WHERE id_task = pIdTask;

    DELETE FROM tb_attachment
    WHERE id_task = pIdTask;

    DELETE FROM tb_checklist_tasks
    WHERE id_task = pIdTask;

    DELETE FROM tb_team_tasks
    WHERE id_task = pIdTask;

    SELECT
      tt.name_task,
      tt.id_block,
      (SELECT project_owner
       FROM tb_blocks tb
       WHERE tt.id_block = tb.id_blocks)
    INTO vNameTask, vIdBlock, vIdProject
    FROM tb_tasks tt
    WHERE id_task = pIdTask;

    DELETE FROM tb_tasks
    WHERE id_task = pIdTask;

    INSERT INTO tb_notifications (id_user, type, old_name, id_block, id_project, target_type)
    VALUES (pIdUser, 3, vNameTask, vIdBlock, vIdProject, 2);

    UPDATE tb_team
    SET notifications = TRUE
    WHERE id_project = vIdProject AND id_user <> pIdUser;

    RETURN TRUE;
  END IF;
  RETURN FALSE;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION buildAttachment(pFileName CHARACTER VARYING, pSize NUMERIC, pIdTask INTEGER,
                                           pPath     CHARACTER VARYING, pIdUser INTEGER)
  RETURNS BOOLEAN AS $$
DECLARE
  vIdAttachment INTEGER;
  vIdBlock      INTEGER;
  vIdProject    INTEGER;
BEGIN
  IF EXISTS(SELECT *
            FROM tb_tasks
            WHERE id_task = pIdTask)
  THEN
    INSERT INTO tb_attachment (file_name, size, id_task, path)
    VALUES (pFileName, pSize, pIdTask, pPath)
    RETURNING id_attachment
      INTO vIdAttachment;

    SELECT
      tt.id_block,
      (SELECT project_owner
       FROM tb_blocks
       WHERE id_blocks = tt.id_block)
    INTO vIdBlock, vIdProject
    FROM tb_tasks tt
    WHERE id_task = pIdTask;

    INSERT INTO tb_notifications (id_attachment, type, target_type, old_name, id_block, id_project, id_task, id_user)
    VALUES (vIdAttachment, 1, 5, pFileName, vIdBlock, vIdProject, pIdTask, pIdUser);

    UPDATE tb_team
    SET notifications = TRUE
    WHERE id_project = vIdProject AND id_user <> pIdUser;

    RETURN TRUE;
  END IF;
  RETURN FALSE;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION getAttachment(pIdTask INTEGER)
  RETURNS TABLE(
    fileName VARCHAR(50),
    size     INTEGER,
    path     VARCHAR(50)
  ) AS $$
BEGIN
  IF EXISTS(SELECT *
            FROM tb_tasks
            WHERE id_task = pIdTask)
  THEN
    RETURN QUERY
    SELECT
      file_name,
      size,
      path
    FROM tb_attachment
    WHERE id_task = pIdTask;
  END IF;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION deleteAttachment(pIdAttachment INTEGER, pIdUser INTEGER)
  RETURNS TABLE(
    path VARCHAR(50)
  ) AS $$

DECLARE
  vPath    VARCHAR(50);
  vOldName VARCHAR(100);
BEGIN
  IF EXISTS(SELECT *
            FROM tb_attachment
            WHERE id_attachment = pIdAttachment)
  THEN
    SELECT
      l.path,
      file_name
    INTO vPath, vOldName
    FROM tb_attachment l
    WHERE id_attachment = pIdAttachment;

    DELETE FROM tb_attachment
    WHERE id_attachment = pIdAttachment;

    INSERT INTO tb_notifications (id_task, target_type, id_user, old_name, type, id_block, id_project)
    VALUES ((SELECT id_task
             FROM tb_attachment
             WHERE id_attachment = pIdAttachment),
            5,
            pIdUser,
            vOldName,
            3,
            (SELECT id_block
             FROM tb_tasks
             WHERE id_task = (SELECT id_task
                              FROM tb_attachment
                              WHERE id_attachment = pIdAttachment)),
            (SELECT project_owner
             FROM tb_blocks
             WHERE id_blocks = (SELECT id_block
                                FROM tb_tasks
                                WHERE id_task = (SELECT id_task
                                                 FROM tb_attachment
                                                 WHERE id_attachment = pIdAttachment))));

    UPDATE tb_team
    SET notifications = TRUE
    WHERE id_project = (SELECT project_owner
                        FROM tb_blocks
                        WHERE id_blocks = (SELECT id_block
                                           FROM tb_tasks
                                           WHERE id_task = (SELECT id_task
                                                            FROM tb_attachment
                                                            WHERE id_attachment = pIdAttachment))) AND
          id_user <> pIdUser;

    RETURN QUERY
    SELECT vPath;
  END IF;
END;
$$
LANGUAGE plpgsql;

--SELECT * FROM buildChecklist('[{"namechecklist": "nome","idTask": 77,"checked": false}]' :: JSON)

CREATE OR REPLACE FUNCTION buildChecklist(pChecklist JSON, pIdUser INTEGER)
  RETURNS BOOLEAN AS $$
DECLARE
  vIdBlock     INTEGER;
  vIdProject   INTEGER;
  vIdChecklist INTEGER;
BEGIN
  IF (SELECT "namechecklist"
      FROM json_to_recordset(pChecklist)
        AS x(
           "namechecklist" VARCHAR(100),
           "idTask" INTEGER,
           checked BOOLEAN
           )) IS NOT NULL
  THEN

    INSERT INTO tb_checklist_tasks (name_checklist, id_task, checked)
      SELECT
        "namechecklist",
        "idTask",
        checked
      FROM json_to_recordset(pChecklist)
        AS x(
           "namechecklist" VARCHAR(100),
           "idTask" INTEGER,
           checked BOOLEAN
           )
    RETURNING id_checklist
      INTO vIdChecklist;

  END IF;

  SELECT id_block
  INTO vIdBlock
  FROM tb_tasks
  WHERE id_task = (SELECT "idTask"
                   FROM json_to_recordset(pChecklist)
                     AS x(
                        "namechecklist" VARCHAR(100),
                        "idTask" INTEGER,
                        checked BOOLEAN
                        ));

  SELECT project_owner
  INTO vIdProject
  FROM tb_blocks
  WHERE id_blocks = vIdBlock;

  INSERT INTO tb_notifications (id_task, id_checklist, type, old_name, id_user, id_block, id_project, target_type)
  VALUES ((SELECT "idTask"
           FROM json_to_recordset(pChecklist)
             AS x(
                "namechecklist" VARCHAR(100),
                "idTask" INTEGER,
                checked BOOLEAN
                )),
          vIdChecklist,
          1,
          (SELECT "namechecklist"
           FROM json_to_recordset(pChecklist)
             AS x(
                "namechecklist" VARCHAR(100),
                "idTask" INTEGER,
                checked BOOLEAN
                )),
          pIdUser,
          (SELECT id_block
           FROM tb_tasks
           WHERE id_task = (SELECT "idTask"
                            FROM json_to_recordset(pChecklist)
                              AS x(
                                 "namechecklist" VARCHAR(100),
                                 "idTask" INTEGER,
                                 checked BOOLEAN
                                 ))),
          (SELECT project_owner
           FROM tb_blocks
           WHERE id_blocks = (SELECT id_block
                              FROM tb_tasks
                              WHERE id_task = (SELECT "idTask"
                                               FROM json_to_recordset(pChecklist)
                                                 AS x(
                                                    "namechecklist" VARCHAR(100),
                                                    "idTask" INTEGER,
                                                    checked BOOLEAN
                                                    )))),
          4);

  UPDATE tb_team
  SET notifications = TRUE
  WHERE id_project = (SELECT project_owner
                      FROM tb_blocks
                      WHERE id_blocks = (SELECT id_block
                                         FROM tb_tasks
                                         WHERE id_task = (SELECT "idTask"
                                                          FROM json_to_recordset(pChecklist)
                                                            AS x(
                                                               "namechecklist" VARCHAR(100),
                                                               "idTask" INTEGER,
                                                               checked BOOLEAN
                                                               )))) AND id_user <> pIdUser;


  RETURN TRUE;
END;
$$
LANGUAGE plpgsql;

--SELECT * FROM deleteChecklist(46)

CREATE OR REPLACE FUNCTION deleteChecklist(pIdChecklist INTEGER, pIdUser INTEGER)
  RETURNS BOOLEAN AS $$
DECLARE
  vOldName   VARCHAR(100);
  vIdTask    INTEGER;
  vIdBlock   INTEGER;
  vIdProject INTEGER;
BEGIN
  IF EXISTS(SELECT *
            FROM tb_checklist_tasks
            WHERE id_checklist = pIdChecklist)
  THEN
    DELETE FROM tb_notifications
    WHERE id_checklist = pIdChecklist;

    SELECT name_checklist
    INTO vOldName
    FROM tb_checklist_tasks
    WHERE id_checklist = pIdChecklist;

    SELECT
      id_task,
      (SELECT tt.id_block
       FROM tb_tasks tt
       WHERE tt.id_task = tct.id_task)
    INTO vIdTask, vIdBlock
    FROM tb_checklist_tasks tct
    WHERE id_checklist = pIdChecklist;

    SELECT project_owner
    INTO vIdProject
    FROM tb_blocks
    WHERE id_blocks = vIdBlock;

    INSERT INTO tb_notifications (id_user, type, target_type, id_task, old_name, id_block, id_project)
    VALUES (pIdUser, 3, 5, vIdTask, vOldName, vIdBlock, vIdProject);

    UPDATE tb_team
    SET notifications = TRUE
    WHERE id_project = vIdProject AND id_user <> pIdUser;

    DELETE FROM tb_checklist_tasks
    WHERE id_checklist = pIdChecklist;
    RETURN TRUE;
  END IF;
  RETURN FALSE;
END;
$$
LANGUAGE plpgsql;

--SELECT * FROM searchUsers('joao',107);

CREATE OR REPLACE FUNCTION searchusers(puser CHARACTER VARYING, idproject INTEGER)
  RETURNS TABLE(
    iduser   INTEGER,
    nameuser CHARACTER VARYING,
    username CHARACTER VARYING,
    imguser  CHARACTER VARYING
  )
AS $$
DECLARE
  vIdUser         INTEGER [];
  reg             tb_team%ROWTYPE;
  vIdUnique       INTEGER;
  vErrorProcedure TEXT;
  vErrorMessage   TEXT;
BEGIN
  IF EXISTS(SELECT *
            FROM tb_login
            WHERE tb_login.username LIKE puser OR tb_login.email LIKE puser OR tb_login.name LIKE puser)
  THEN
    vIdUser :=  ARRAY(SELECT id_user
                      FROM tb_login
                      WHERE tb_login.username LIKE puser OR tb_login.email LIKE puser OR tb_login.name LIKE puser);

    FOR reg IN
    SELECT id_user
    FROM tb_team
    WHERE id_user = ANY (vIdUser)
    LOOP
      vIdUser = array_remove(vIdUser, (SELECT id_user
                                       FROM tb_team
                                       WHERE id_user = ANY (vIdUser) AND id_project = idproject
                                       LIMIT 1));
    END LOOP;
    RETURN QUERY
    SELECT
      tb_login.id_user,
      name,
      tb_login.username,
      profile_img
    FROM tb_login
    WHERE tb_login.id_user = ANY (vIdUser)
    LIMIT 10;
  END IF;
  IF EXISTS(SELECT *
            FROM tb_login
            WHERE tb_login.username ILIKE '%' || pUser || '%' OR
                  tb_login.email ILIKE '%' || pUser || '%' OR
                  tb_login.name ILIKE '%' || pUser || '%')
  THEN
    vIdUser :=  ARRAY(SELECT id_user
                      FROM tb_login
                      WHERE tb_login.username ILIKE '%' || pUser || '%' OR
                            email ILIKE '%' || pUser || '%' OR
                            name ILIKE '%' || pUser || '%');

    IF vIdUnique = ANY (vIdUser)
    THEN
      vIdUser := array_remove(vIdUser, (SELECT id_user
                                        FROM tb_login
                                        WHERE tb_login.username LIKE puser OR tb_login.email LIKE puser OR
                                              tb_login.name LIKE puser));
    END IF;

    FOR reg IN
    SELECT id_user
    FROM tb_team
    WHERE id_user = ANY (vIdUser)
    LOOP
      vIdUser = array_remove(vIdUser, (SELECT id_user
                                       FROM tb_team
                                       WHERE id_user = ANY (vIdUser) AND id_project = idproject
                                       LIMIT 1));
    END LOOP;

    RETURN QUERY
    SELECT
      tb_login.id_user,
      name,
      tb_login.username,
      profile_img
    FROM tb_login
    WHERE tb_login.id_user = ANY (vIdUser)

    LIMIT 10;
  END IF;
  EXCEPTION WHEN OTHERS
  THEN
    GET STACKED DIAGNOSTICS vErrorProcedure = MESSAGE_TEXT;
    GET STACKED DIAGNOSTICS vErrorMessage = PG_EXCEPTION_CONTEXT;
    RAISE EXCEPTION 'Internal Error: (%) %', vErrorProcedure, vErrorMessage;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION insertTeamTasks(users JSON)
  RETURNS BOOLEAN AS $$
BEGIN
  INSERT INTO tb_team_tasks (id_task, id_user)
    SELECT
      idtask,
      iduser
    FROM json_to_recordset(users)
      AS x(
         idtask INTEGER,
         iduser INTEGER
         );
  RETURN TRUE;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION newComment(pIdTask INTEGER, pComment TEXT, pIdUser INTEGER)
  RETURNS TABLE(
    idComment INTEGER
  ) AS $$
DECLARE
  vIdComment INTEGER;
  vIdBlock   INTEGER;
  vIdProject INTEGER;
BEGIN
  IF EXISTS(SELECT *
            FROM tb_tasks
            WHERE id_task = pIdTask)
  THEN
    INSERT INTO tb_comments (id_task, comment)
    VALUES (pIdTask, pComment)
    RETURNING id_comment
      INTO vIdComment;

    SELECT
      tt.id_block,
      (SELECT project_owner
       FROM tb_blocks
       WHERE id_blocks = tt.id_block)
    INTO vIdBlock, vIdProject
    FROM tb_tasks tt
    WHERE id_task = pIdTask;

    INSERT INTO tb_notifications (id_comment, type, target_type, id_user, id_task, id_block, id_project)
    VALUES (vIdComment, 1, 3, pIdUser, pIdTask, vIdBlock, vIdProject);

    UPDATE tb_team
    SET notifications = TRUE
    WHERE id_project = vIdProject AND id_user <> pIdUser;

    RETURN QUERY
    SELECT vIdComment;
  END IF;
END;
$$
LANGUAGE plpgsql;

--SELECT * FROM changeComment(2, 'joao1234')

CREATE OR REPLACE FUNCTION changeComment(pIdComment INTEGER, pNewComment CHARACTER VARYING, pIdUser INTEGER)
  RETURNS BOOLEAN AS $$
DECLARE
  vIdTask    INTEGER;
  vIdBlock   INTEGER;
  vIdProject INTEGER;
BEGIN
  IF EXISTS(SELECT *
            FROM tb_comments
            WHERE id_comment = pIdComment)
  THEN
    UPDATE tb_comments
    SET comment = pNewComment
    WHERE id_comment = pIdComment;

    SELECT
      tc.id_task,
      (SELECT id_block
       FROM tb_tasks tt
       WHERE tt.id_task = tc.id_task)
    INTO vIdTask, vIdBlock
    FROM tb_comments tc
    WHERE id_comment = pIdComment;

    SELECT project_owner
    INTO vIdProject
    FROM tb_blocks
    WHERE id_blocks = vIdBlock;

    INSERT INTO tb_notifications (id_user, type, target_type, id_comment, id_task, id_block, id_project)
    VALUES (pIdUser, 2, 3, pIdComment, vIdTask, vIdBlock, vIdProject);

    UPDATE tb_team
    SET notifications = TRUE
    WHERE id_project = vIdProject AND id_user <> pIdUser;

    RETURN TRUE;
  END IF;
  RETURN FALSE;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION deleteComment(pIdComment INTEGER, pIdUser INTEGER)
  RETURNS BOOLEAN AS $$
DECLARE
  vIdTask    INTEGER;
  vIdBlock   INTEGER;
  vIdProject INTEGER;
BEGIN
  IF EXISTS(SELECT *
            FROM tb_comments
            WHERE id_comment = pIdComment)
  THEN
    DELETE FROM tb_notifications
    WHERE id_comment = pIdComment;

    DELETE
    FROM tb_comments
    WHERE id_comment = pIdComment;

    SELECT
      tc.id_task,
      (SELECT id_block
       FROM tb_tasks tt
       WHERE tt.id_task = tc.id_task)
    INTO vIdTask, vIdBlock
    FROM tb_comments tc
    WHERE id_comment = pIdComment;

    SELECT project_owner
    INTO vIdProject
    FROM tb_blocks
    WHERE id_blocks = vIdBlock;

    INSERT INTO tb_notifications (id_user, type, target_type, id_task, id_block, id_project)
    VALUES (pIdUser, 3, 3, vIdTask, vIdBlock, vIdProject);

    UPDATE tb_team
    SET notifications = TRUE
    WHERE id_project = vIdProject AND id_user <> pIdUser;

    RETURN TRUE;
  END IF;
  RETURN FALSE;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION ChangeStatusChecklist(pIdChecklist INTEGER, pIdUser INTEGER)
  RETURNS TABLE(
    rStatus TEXT
  ) AS $$
DECLARE
  vStatus    BOOLEAN;
  vIdTask    INTEGER;
  vIdBlock   INTEGER;
  vIdProject INTEGER;
BEGIN
  IF EXISTS(SELECT *
            FROM tb_checklist_tasks
            WHERE id_checklist = pIdChecklist)
  THEN

    SELECT checked
    INTO vStatus
    FROM tb_checklist_tasks
    WHERE id_checklist = pIdChecklist;

    UPDATE tb_checklist_tasks
    SET checked = NOT checked
    WHERE id_checklist = pIdChecklist;

    SELECT
      id_task,
      (SELECT id_block
       FROM tb_tasks
       WHERE tct.id_task = tb_tasks.id_task)
    INTO vIdTask, vIdBlock
    FROM tb_checklist_tasks tct
    WHERE id_checklist = pIdChecklist;

    SELECT project_owner
    INTO vIdProject
    FROM tb_blocks
    WHERE id_blocks = vIdBlock;

    IF vStatus = TRUE
    THEN

      INSERT INTO tb_notifications (id_checklist, type, target_type, id_user, id_task, id_block, id_project)
      VALUES (pIdChecklist, 6, 4, pIdUser, vIdTask, vIdBlock, vIdProject);

      UPDATE tb_team
      SET notifications = TRUE
      WHERE id_project = vIdProject AND id_user <> pIdUser;

      RETURN QUERY
      SELECT 'desmarcada' :: TEXT;

    ELSE

      INSERT INTO tb_notifications (id_checklist, type, target_type, id_user, id_task, id_block, id_project)
      VALUES (pIdChecklist, 5, 4, pIdUser, vIdTask, vIdBlock, vIdProject);

      UPDATE tb_team
      SET notifications = TRUE
      WHERE id_project = vIdProject AND id_user <> pIdUser;

      RETURN QUERY
      SELECT 'marcada' :: TEXT;


    END IF;
  ELSE
    RETURN QUERY
    SELECT 'Erro' :: TEXT;
  END IF;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION changeNameChecklist(pIdChecklist INTEGER, pName CHARACTER VARYING, pIdUser INTEGER)
  RETURNS BOOLEAN AS $$
DECLARE
  vOldName   VARCHAR(100);
  vIdTask    INTEGER;
  vIdBlock   INTEGER;
  vIdProject INTEGER;
BEGIN
  IF EXISTS(SELECT *
            FROM tb_checklist_tasks
            WHERE id_checklist = pIdChecklist)
  THEN

    SELECT name_checklist
    INTO vOldName
    FROM tb_checklist_tasks
    WHERE id_checklist = pIdChecklist;

    UPDATE tb_checklist_tasks
    SET name_checklist = pName
    WHERE id_checklist = pIdChecklist;

    SELECT
      id_task,
      (SELECT id_block
       FROM tb_tasks
       WHERE tct.id_task = tb_tasks.id_task)
    INTO vIdTask, vIdBlock
    FROM tb_checklist_tasks tct
    WHERE id_checklist = pIdChecklist;

    SELECT project_owner
    INTO vIdProject
    FROM tb_blocks
    WHERE id_blocks = vIdBlock;

    INSERT INTO tb_notifications (id_checklist, type, target_type, id_user, old_name, new_name, id_task, id_block, id_project)
    VALUES (pIdChecklist, 2, 4, pIdUser, vOldName, pName, vIdTask, vIdBlock, vIdProject);

    UPDATE tb_team
    SET notifications = TRUE
    WHERE id_project = vIdProject AND id_user <> pIdUser;

    RETURN TRUE;
  END IF;
  RETURN FALSE;
END;
$$
LANGUAGE plpgsql;

--SELECT * FROM updatePositions('[58,59,60,61,62]' :: JSON)

CREATE OR REPLACE FUNCTION updatePositions(pPositions JSON, pOldPositions JSON)
  RETURNS BOOLEAN AS $$
DECLARE
  vIdTarefa INTEGER;
  vIndex    INTEGER := 0;
BEGIN

  FOR vIdTarefa IN SELECT *
                   FROM json_array_elements(pPositions) LOOP
    RAISE NOTICE '[%] %', vIdTarefa, vIndex;
    UPDATE tb_tasks
    SET position = vIndex
    WHERE id_task = vIdTarefa;
    vIndex := vIndex + 1;
  END LOOP;
  vIndex := 0;
  FOR vIdTarefa IN SELECT *
                   FROM json_array_elements(pOldPositions) LOOP
    RAISE NOTICE '[%] %', vIdTarefa, vIndex;
    UPDATE tb_tasks
    SET position = vIndex
    WHERE id_task = vIdTarefa;
    vIndex := vIndex + 1;
  END LOOP;
  RETURN TRUE;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION insertMembersTask(pIdTask INTEGER, pIdUser INTEGER, pIdOldUser INTEGER)
  RETURNS BOOLEAN AS $$
BEGIN
  IF EXISTS(SELECT *
            FROM tb_tasks
            WHERE id_task = pIdTask)
     AND NOT EXISTS(SELECT *
                    FROM tb_team_tasks
                    WHERE pIdTask = id_task AND pIdUser = id_user)
  THEN
    INSERT INTO tb_team_tasks (id_task, id_user) VALUES (pIdTask, pIdUser);

    INSERT INTO tb_notifications (id_task, id_block, id_project, type, target_type, id_user, id_new_user)
    VALUES (pIdTask,
            (SELECT id_block
             FROM tb_tasks
             WHERE id_task = pIdTask),
            (SELECT project_owner
             FROM tb_blocks
             WHERE id_blocks = (SELECT id_block
                                FROM tb_tasks
                                WHERE id_task = pIdTask)), 7, 2, pIdOldUser, pIdUser);

    UPDATE tb_team
    SET notifications = TRUE
    WHERE id_project = (SELECT project_owner
                        FROM tb_blocks
                        WHERE id_blocks = (SELECT id_block
                                           FROM tb_tasks
                                           WHERE id_task = pIdTask)) AND id_user <> pIdOldUser;

    RETURN TRUE;
  END IF;
  RETURN FALSE;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION removeMemberTask(pIdRelation INTEGER, pIdUser INTEGER)
  RETURNS BOOLEAN AS $$
DECLARE
  vIdTask        INTEGER;
  vIdUserRemoved INTEGER;
BEGIN
  IF EXISTS(SELECT *
            FROM tb_team_tasks
            WHERE pIdRelation = id_team_task)
  THEN

    SELECT
      id_task,
      id_user
    INTO vIdTask, vIdUserRemoved
    FROM tb_team_tasks
    WHERE id_team_task = pIdRelation;

    DELETE FROM tb_team_tasks
    WHERE pIdRelation = id_team_task;

    IF pIdUser = vIdUserRemoved
    THEN
      INSERT INTO tb_notifications (id_task, id_block, id_project, type, target_type, id_user)
      VALUES (vIdTask,
              (SELECT id_block
               FROM tb_tasks
               WHERE id_task = vIdTask),
              (SELECT project_owner
               FROM tb_blocks
               WHERE id_blocks = (SELECT id_block
                                  FROM tb_tasks
                                  WHERE id_task = vIdTask)),
              8,
              2,
              pIdUser);

      UPDATE tb_team
      SET notifications = TRUE
      WHERE id_project = (SELECT project_owner
                          FROM tb_blocks
                          WHERE id_blocks = (SELECT id_block
                                             FROM tb_tasks
                                             WHERE id_task = vIdTask)) AND id_user <> pIdUser;
      RETURN TRUE;
    ELSE
      INSERT INTO tb_notifications (id_task, id_block, id_project, type, target_type, id_user, id_new_user)
      VALUES (vIdTask,
              (SELECT id_block
               FROM tb_tasks
               WHERE id_task = vIdTask),
              (SELECT project_owner
               FROM tb_blocks
               WHERE id_blocks = (SELECT id_block
                                  FROM tb_tasks
                                  WHERE id_task = vIdTask)),
              11,
              2,
              pIdUser,
              vIdUserRemoved);

      UPDATE tb_team
      SET notifications = TRUE
      WHERE id_project = (SELECT project_owner
                          FROM tb_blocks
                          WHERE id_blocks = (SELECT id_block
                                             FROM tb_tasks
                                             WHERE id_task = vIdTask)) AND id_user <> pIdUser;

      RETURN TRUE;
    END IF;
  END IF;
  RETURN FALSE;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION sawNotification(pIdUser INTEGER)
  RETURNS BOOLEAN AS $$
BEGIN

  UPDATE tb_team
  SET notifications = FALSE
  WHERE id_user = pIdUser;

  RETURN TRUE;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION getNotifications(pIdUser INTEGER)
  RETURNS TABLE(
    idTask         INTEGER,
    nameTask       VARCHAR(100),
    idBlock        INTEGER,
    nameBlock      VARCHAR(100),
    idProject      INTEGER,
    nameProject    VARCHAR(100),
    idUser         INTEGER,
    nameUser       VARCHAR(100),
    imgUser        VARCHAR(100),
    idAttachment   INTEGER,
    idComment      INTEGER,
    idChecklist    INTEGER,
    type           INTEGER,
    idBlockFinal   INTEGER,
    nameBlockFinal VARCHAR(100),
    oldName        VARCHAR(100),
    newName        VARCHAR(100),
    targetType     INTEGER,
    idNewUser      INTEGER,
    nameNewUser    VARCHAR(100),
    imgNewUser     VARCHAR(100),
    date           TIMESTAMP
  ) AS $$
DECLARE
  vArrayProjects INTEGER [];
BEGIN
  vArrayProjects := ARRAY(SELECT id_project
                          FROM tb_team
                          WHERE id_user = pIdUser);
  RETURN QUERY
  SELECT
    tn.id_task,
    (SELECT name_task
     FROM tb_tasks
     WHERE tn.id_task = tb_tasks.id_task),
    tn.id_block,
    (SELECT name_blocks
     FROM tb_blocks
     WHERE tn.id_block = tb_blocks.id_blocks),
    tn.id_project,
    (SELECT name_project
     FROM tb_projects
     WHERE tn.id_project = tb_projects.id_project),
    tn.id_user,
    (SELECT name
     FROM tb_login
     WHERE tn.id_user = tb_login.id_user),
    (SELECT profile_img
     FROM tb_login
     WHERE tn.id_user = tb_login.id_user),
    tn.id_attachment,
    tn.id_comment,
    tn.id_checklist,
    tn.type,
    tn.id_block_final,
    (SELECT name_blocks
     FROM tb_blocks
     WHERE id_blocks = tn.id_block_final),
    tn.old_name,
    tn.new_name,
    tn.target_type,
    tn.id_new_user,
    (SELECT name
     FROM tb_login
     WHERE tn.id_new_user = tb_login.id_user),
    (SELECT profile_img
     FROM tb_login
     WHERE tn.id_new_user = tb_login.id_user),
    tn.date
  FROM tb_notifications tn
  WHERE (id_project = ANY (vArrayProjects)) AND ((SELECT active
                                                  FROM tb_projects
                                                  WHERE tn.id_project = tb_projects.id_project) = TRUE) AND id_user <> pIdUser
  ORDER BY date DESC
  LIMIT 5;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION newNotifications(pIdUser INTEGER)
  RETURNS BOOLEAN AS $$
DECLARE
  vNotifications   BOOLEAN [];
  newNotifications BOOLEAN;
BEGIN

  vNotifications := ARRAY(SELECT notifications
                          FROM tb_team
                          WHERE id_user = pIdUser);

  IF TRUE = ANY (vNotifications)
  THEN
    newNotifications = TRUE;
  ELSE
    newNotifications = FALSE;
  END IF;
  RETURN newNotifications;
END;
$$
LANGUAGE plpgsql;
