--SELECT * FROM tb_tasks;

--INSERT INTO tb_blocks(name_blocks,project_owner) values('teste do teste', 73)
--INSERT INTO tb_tasks(name_task, id_block, description, position) values('teste do teste', 2, 'teste', 1);
--UPDATE tb_login SET profile_img = '/imgsUser/default.png'

--INSERT INTO tb_comments(id_task,comment) values(3,'teste0'),(3,'teste1'),(3,'teste2'),(3,'teste3')

CREATE OR REPLACE FUNCTION emailNewUser(pEmail VARCHAR(50))
  RETURNS BOOLEAN AS $$
BEGIN
  IF EXISTS(SELECT email
            FROM tb_login
            WHERE email ILIKE pEmail)
  THEN
    RETURN TRUE;
  END IF;
  RETURN FALSE;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION loginU(emailD VARCHAR, passw VARCHAR)
  RETURNS TABLE(
    id           INTEGER,
    email        VARCHAR(50),
    password     VARCHAR(20),
    username     VARCHAR(50),
    statusEmail  BOOLEAN,
    senhaCorreta BOOLEAN
  ) AS $$
BEGIN
  RETURN QUERY
  SELECT
    tb_login.id_user,
    tb_login.email,
    tb_login.username,
    tb_login.password,
    tb_login."authEmail",
    (tb_login.password = $2)
  FROM tb_login
  WHERE tb_login.email ILIKE $1 OR tb_login.username ILIKE $1;
END
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION deleteuser(usern CHARACTER VARYING)
  RETURNS BOOLEAN AS $$
BEGIN
  IF EXISTS(SELECT
              username,
              email
            FROM tb_login
            WHERE username ILIKE $1 OR email ILIKE $1)
  THEN
    DELETE FROM tb_login
    WHERE username ILIKE $1 OR email ILIKE $1;
    RETURN TRUE;
  END IF;
  RETURN FALSE;
END
$$
LANGUAGE plpgsql;

--SELECT * FROM deleteuser('joao1');

CREATE OR REPLACE FUNCTION changeuser(pass   CHARACTER VARYING, usern CHARACTER VARYING, usertoken CHARACTER VARYING,
                                      emailp CHARACTER VARYING, nomep CHARACTER VARYING)
  RETURNS TABLE(
    idUser    INTEGER,
    emaild    CHARACTER VARYING,
    namep     CHARACTER VARYING,
    usernamer CHARACTER VARYING,
    imageuser CHARACTER VARYING)
LANGUAGE plpgsql
AS $$
DECLARE
  vIdUser INTEGER;
BEGIN
  IF NOT EXISTS(SELECT
                  l.username,
                  l.email
                FROM tb_login l
                WHERE l.username = $2 OR l.email = $4
                EXCEPT (SELECT
                          l.username,
                          l.email
                        FROM tb_login l
                        WHERE l.username = $3 OR l.email = $3))
  THEN

    SELECT id_user
    INTO vIdUser
    FROM tb_login l
    WHERE l.username = $3 OR l.email = $3;

    UPDATE tb_login l
    SET username = $2,
      email      = $4,
      name       = $5
    WHERE l.username = $3 OR l.email = $3;

    RETURN QUERY
    SELECT
      vIdUser,
      $4,
      $5,
      $2,
      tb_login.profile_img
    FROM tb_login;
  END IF;
END
$$;

CREATE OR REPLACE FUNCTION changepass(usern   CHARACTER VARYING, oldpass CHARACTER VARYING, newpass CHARACTER VARYING,
                                      whocall BOOLEAN)
  RETURNS BOOLEAN AS $$
BEGIN
  IF whocall = TRUE
  THEN

    IF EXISTS(SELECT
                username,
                password
              FROM tb_login
              WHERE (username ILIKE $1 OR email ILIKE $1) AND password = $2)
    THEN
      UPDATE tb_login
      SET password = $3
      WHERE username ILIKE $1 OR email ILIKE $1;
      RETURN TRUE;
    END IF;
    RETURN FALSE;
  ELSE
    IF EXISTS(SELECT
                username,
                password
              FROM tb_login
              WHERE username ILIKE $1 OR email ILIKE $1)
    THEN
      UPDATE tb_login
      SET password = $3
      WHERE username ILIKE $1 OR email ILIKE $1;
      RETURN TRUE;
    END IF;
    RETURN FALSE;

  END IF;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION newuser(emailD CHARACTER VARYING, passw CHARACTER VARYING, img CHARACTER VARYING,
                                   nameP  CHARACTER VARYING, usern CHARACTER VARYING)
  RETURNS TABLE(
    idNewUser INTEGER
  )
LANGUAGE plpgsql
AS $$
DECLARE
  vIdNewUser INTEGER;
BEGIN
  IF NOT exists(SELECT *
                FROM tb_login
                WHERE emailD = tb_login.email OR usern = tb_login.username)
  THEN
    INSERT INTO tb_login (email, password, profile_img, name, username) VALUES ($1, $2, $3, $4, $5)
    RETURNING id_user
      INTO vIdNewUser;
    RETURN QUERY
    SELECT vIdNewUser;
  ELSE
    RETURN QUERY
    SELECT 0;
  END IF;
END
$$;

CREATE OR REPLACE FUNCTION consult()
  RETURNS TABLE(
    email     VARCHAR(50),
    username  VARCHAR(50),
    password  VARCHAR(20),
    img       VARCHAR(50),
    name      VARCHAR(50),
    emailAuth BOOLEAN
  ) AS $$
BEGIN
  RETURN QUERY
  SELECT
    tb_login.email,
    tb_login.username,
    tb_login.password,
    tb_login.profile_img,
    tb_login.name,
    tb_login."authEmail"
  FROM tb_login;
END
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION verify_email(usern CHARACTER VARYING)
  RETURNS TABLE(

    statusEmail BOOLEAN
  )
AS $$
BEGIN
  IF EXISTS(SELECT "authEmail"
            FROM tb_login l
            WHERE l.username ILIKE $1)
  THEN
    RETURN QUERY
    SELECT "authEmail"
    FROM tb_login l
    WHERE l.username ILIKE $1;
  END IF;
END
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION verify_img(imgPath CHARACTER VARYING, usern CHARACTER VARYING)
  RETURNS BOOLEAN
AS $$
BEGIN
  IF EXISTS(SELECT
              profile_img,
              username,
              email
            FROM tb_login l
            WHERE l.email = usern OR l.username = usern)
  THEN
    UPDATE tb_login l
    SET profile_img = imgPath
    WHERE l.email ILIKE usern OR l.username ILIKE usern;
    RETURN TRUE;
  ELSE
    RETURN FALSE;
  END IF;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION verify_imgproject(imgPath CHARACTER VARYING, usern INTEGER)
  RETURNS BOOLEAN
AS $$
BEGIN
  IF EXISTS(SELECT
              img_project,
              name_project
            FROM tb_projects
            WHERE tb_projects.id_project = usern)
  THEN
    UPDATE tb_projects
    SET img_project = imgPath
    WHERE tb_projects.id_project = usern;
    RETURN TRUE;
  ELSE
    RETURN FALSE;
  END IF;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION imgDb(usern CHARACTER VARYING)
  RETURNS TABLE(
    currentImg VARCHAR(50)
  ) AS $$
BEGIN
  IF EXISTS(SELECT
              l.username,
              l.profile_img
            FROM tb_login l
            WHERE l.username ILIKE $1)
  THEN

  END IF;
END;
$$;

CREATE OR REPLACE FUNCTION removeImg(pIdUser INTEGER)
  RETURNS TABLE(
    path VARCHAR(50)
  ) AS $$
DECLARE
  vPath VARCHAR(50);
BEGIN
  IF EXISTS(SELECT *
            FROM tb_login
            WHERE id_user = pIdUser AND profile_img <> '/imgsUser/default.png')
  THEN
    SELECT profile_img
    INTO vPath
    FROM tb_login
    WHERE id_user = pIdUser;

    UPDATE tb_login
    SET profile_img = '/imgsUser/default.png'
    WHERE id_user = pIdUser;

    RETURN QUERY
    SELECT vPath;
  END IF;
END;
$$
LANGUAGE plpgsql;

--SELECT * FROM verify_img('/default.png','joaoo');

--UPDATE tb_login SET profile_img = '/default.png'

--SELECT * FROM verify_email('joao1559');

CREATE OR REPLACE FUNCTION consultuser(usern VARCHAR)
  RETURNS TABLE(
    id_user    INTEGER,
    email      VARCHAR(50),
    username   VARCHAR(50),
    PASSWORD   VARCHAR(20),
    img        VARCHAR(50),
    NAME       VARCHAR(50),
    statusAuth BOOLEAN
  ) AS $$
BEGIN
  RETURN QUERY
  SELECT
    tb_login.id_user,
    tb_login.email,
    tb_login.username,
    tb_login.password,
    tb_login.profile_img,
    tb_login.name,
    tb_login."authEmail"
  FROM tb_login
  WHERE tb_login.username ILIKE $1 OR tb_login.email ILIKE $1;
END
$$
LANGUAGE plpgsql;

--SELECT * FROM consultuser('joao@joao.com')

CREATE OR REPLACE FUNCTION verify_token(usern CHARACTER VARYING)
  RETURNS TABLE(
    userA  VARCHAR(50),
    status TEXT
  )
LANGUAGE plpgsql
AS $$
BEGIN
  IF EXISTS(SELECT
              l.username,
              l.email
            FROM tb_login l
            WHERE l.username ILIKE $1 OR l.email ILIKE $1 AND "authEmail" = FALSE)
  THEN
    UPDATE tb_login l
    SET "authEmail" = TRUE
    WHERE l.username ILIKE $1 OR l.email ILIKE $1;
    RETURN QUERY
    SELECT
      $1,
      'Autenticado com sucesso' :: TEXT;
  END IF;
  IF EXISTS(SELECT
              l.username,
              l.email
            FROM tb_login l
            WHERE l.username ILIKE $1 OR l.email ILIKE $1 AND "authEmail" = TRUE)
  THEN
    RETURN QUERY
    SELECT
      $1,
      'JÃ¡ autenticado' :: TEXT;
  END IF;
END
$$;

--SELECT * FROM verify_token('A@A.com');

CREATE OR REPLACE FUNCTION passwordToEmail(usern CHARACTER VARYING)
  RETURNS TABLE(
    passwordR VARCHAR(20),
    nameuser  VARCHAR(50)
  ) AS $$
BEGIN
  IF EXISTS(SELECT
              l.username,
              l.email,
              l.password
            FROM tb_login l
            WHERE l.username ILIKE usern OR l.email ILIKE usern)
  THEN
    RETURN QUERY
    SELECT
      l.username,
      l.password,
      l.name
    FROM tb_login l
    WHERE l.username ILIKE usern OR l.email ILIKE usern;
  END IF;
END;
$$
LANGUAGE plpgsql;

--SELECT * FROM passwordToEmail('joao.vitor@smn.com.br');

CREATE OR REPLACE FUNCTION emailexists(emailuser CHARACTER VARYING)
  RETURNS TABLE(
    usern  VARCHAR(50),
    emailu VARCHAR(50),
    passw  VARCHAR(50)
  ) AS $$
BEGIN
  IF EXISTS(SELECT l.email
            FROM tb_login l
            WHERE l.email ILIKE $1)
  THEN
    RETURN QUERY
    SELECT
      l.username,
      l.email,
      l.password
    FROM tb_login l
    WHERE l.email ILIKE $1;
  END IF;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION relogin(usernameD CHARACTER VARYING)
  RETURNS TABLE(
    usern VARCHAR(50),
    passw VARCHAR(50)
  ) AS $$
BEGIN
  IF EXISTS(SELECT
              l.username,
              l.email
            FROM tb_login l
            WHERE l.username ILIKE $1 OR l.email ILIKE $1)
  THEN
    RETURN QUERY
    SELECT
      l.username,
      l.password
    FROM tb_login l
    WHERE l.username ILIKE $1 OR l.email ILIKE $1;
  END IF;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION newproject(nameProject CHARACTER VARYING, idDono INTEGER, descricao CHARACTER VARYING,
                                      imgProject  CHARACTER VARYING)
  RETURNS TABLE(
    idproject INTEGER
  ) AS $$
DECLARE
  idprojectR INTEGER;
BEGIN
  IF EXISTS(SELECT l.id_user
            FROM tb_login l
            WHERE l.id_user = idDono)
  THEN
    INSERT INTO tb_projects (name_project, id_user_owner, description, img_project) VALUES ($1, $2, $3, $4)
    RETURNING id_project
      INTO idprojectR;
    RETURN QUERY
    SELECT idprojectR;
  END IF;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION insertTeamNewProject(pTeam JSON)
  RETURNS BOOLEAN AS $$
BEGIN
  INSERT INTO tb_team (id_project, id_user, permissions)
    SELECT
      idProject,
      idUser,
      permission
    FROM json_to_recordset(pTeam)
      AS x(
         idProject INTEGER,
         idUser INTEGER,
         permission BOOLEAN
         )
  RETURNING TRUE;
END;
$$
LANGUAGE plpgsql;

--SELECT * FROM getproject(25);

CREATE OR REPLACE FUNCTION getproject(usern INTEGER)
  RETURNS TABLE(
    id_project INTEGER,
    namep      VARCHAR(50),
    descrip    TEXT,
    img        VARCHAR(50)
  ) AS $$
BEGIN
  RETURN QUERY
  SELECT
    tb_projects.id_project,
    name_project,
    description,
    img_project
  FROM tb_projects
  WHERE tb_projects.id_project IN (SELECT tb_team.id_project
                                   FROM tb_team
                                   WHERE usern = id_user) AND active <> FALSE;
END;
$$
LANGUAGE plpgsql;

--SELECT * FROM getprojectsearch(73,25);

CREATE OR REPLACE FUNCTION getprojectsearch(idpro INTEGER, iduser INTEGER)
  RETURNS TABLE(
    namep   VARCHAR(50),
    descrip TEXT,
    img     VARCHAR(50),
    team    JSON
  ) AS $$
BEGIN
  IF EXISTS(SELECT id_project
            FROM tb_team
            WHERE id_project = $1 AND id_user = $2)
  THEN
    RETURN QUERY
    SELECT
      name_project,
      description,
      img_project,
      (
        SELECT COALESCE(json_agg(teamJson), '[]')
        FROM (SELECT
                tb_team.id_user,
                name,
                profile_img,
                username,
                permissions
              FROM tb_team
                INNER JOIN tb_login ON tb_login.id_user = tb_team.id_user
              WHERE id_project = idpro
              ORDER BY permissions DESC) AS teamJson
      ) teams
    FROM tb_projects

    WHERE tb_projects.id_project = idpro;
  END IF;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION changeproject(idproj INTEGER, namep CHARACTER VARYING, descrip CHARACTER VARYING,
                                         imgp   CHARACTER VARYING, permission BOOLEAN)
  RETURNS TABLE(
    idprojectR INTEGER
  ) AS $$
DECLARE
  idproject INTEGER;
BEGIN
  IF permission <> FALSE AND
     EXISTS(SELECT *
            FROM tb_projects
            WHERE id_project = idproj)
  THEN
    UPDATE tb_projects
    SET
      name_project = namep,
      description  = descrip,
      img_project  = imgp,
      active       = TRUE
    WHERE id_project = idproj
    RETURNING id_project
      INTO idproject;
    RETURN QUERY
    SELECT idproject;
  END IF;
END;
$$
LANGUAGE plpgsql;

--SELECT * FROM deactivateProject(99,25);

CREATE OR REPLACE FUNCTION deactivateProject(idproject INTEGER, idUser INTEGER)
  RETURNS BOOLEAN AS $$
BEGIN
  IF EXISTS(SELECT *
            FROM tb_projects
            WHERE id_project = $1 AND active = TRUE)
     AND ((SELECT permissions
           FROM tb_team
           WHERE id_user = idUser AND id_project = idproject) = TRUE)
  THEN
    UPDATE tb_projects
    SET active = FALSE
    WHERE id_project = $1;
    RETURN TRUE;
  END IF;
  RETURN FALSE;
END;
$$
LANGUAGE plpgsql;

--SELECT * FROM timeproject(73,22,false,

CREATE OR REPLACE FUNCTION timeproject(pIdProject INTEGER, pIdUser INTEGER, permission BOOLEAN, pIdAdmin INTEGER)
  RETURNS BOOLEAN AS $$
BEGIN
  IF EXISTS(SELECT *
            FROM tb_team
            WHERE id_user = pIdAdmin AND id_project = pIdProject AND permissions = TRUE)
  THEN
    INSERT
    INTO tb_team (id_project, id_user, permissions) VALUES (pIdProject, pIdUser, permission);
    RETURN TRUE;
  END IF;
  RETURN FALSE;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION insertOwner(pIdProject INTEGER, pIdUser INTEGER, permission BOOLEAN)
  RETURNS BOOLEAN AS $$
BEGIN
  IF EXISTS(SELECT *
            FROM tb_projects
            WHERE id_project = pIdProject)
  THEN
    INSERT
    INTO tb_team (id_project, id_user, permissions) VALUES (pIdProject, pIdUser, permission);
    RETURN TRUE;
  END IF;
  RETURN FALSE;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION verify_permission(idproj INTEGER, iduser INTEGER)
  RETURNS TABLE(
    idproject  INTEGER,
    iduserR    INTEGER,
    permission BOOLEAN
  ) AS $$
BEGIN
  IF EXISTS(SELECT *
            FROM tb_team
            WHERE idproj = id_project AND iduser = id_user)
  THEN
    RETURN QUERY
    SELECT
      id_project,
      id_user,
      permissions
    FROM tb_team
    WHERE idproj = id_project AND iduser = id_user;
  END IF;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION exitProject(pIdUser INTEGER, pIdProject INTEGER)
  RETURNS TABLE(
    status INTEGER
  ) AS $$
DECLARE
  vQntdAdmins  INTEGER;
  vQntdMembers INTEGER;
BEGIN

  IF EXISTS(SELECT *
            FROM tb_team
            WHERE id_user = pIdUser AND id_project = pIdProject AND permissions = FALSE)
  THEN
    DELETE FROM tb_team
    WHERE id_user = pIdUser AND id_project = pIdProject;
    RETURN QUERY
    SELECT 1;
  END IF;

  SELECT COUNT(id_user)
  OVER (
    PARTITION BY 1 )
  INTO vQntdAdmins
  FROM tb_team
  WHERE id_project = pIdProject
        AND permissions
  LIMIT 1;

  SELECT COUNT(id_user)
  OVER (
    PARTITION BY 1 )
  INTO vQntdMembers
  FROM tb_team
  WHERE id_project = pIdProject
        AND permissions = FALSE
  LIMIT 1;

  IF vQntdAdmins > 1
  THEN

    DELETE FROM tb_team
    WHERE id_user = pIdUser AND id_project = pIdProject;
    RETURN QUERY
    SELECT 2;
  ELSEIF vQntdAdmins > 1 AND vQntdMembers > 0
    THEN
      RETURN QUERY
      SELECT 3;
  ELSEIF vQntdAdmins = 1 AND vQntdMembers = 0
    THEN
      EXECUTE deactivateProject(pIdProject, pIdUser);
      RETURN QUERY
      SELECT 4;
  END IF;
  RETURN QUERY
  SELECT 0;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION removeUsersTeam(idproj     INTEGER, idusert INTEGER, permission BOOLEAN,
                                           iduseralvo INTEGER)
  RETURNS TABLE(
    statusCode INTEGER
  ) AS $$
DECLARE
  vStatus INTEGER;
BEGIN
  IF permission <> FALSE
  THEN
    IF EXISTS(SELECT *
              FROM tb_team
              WHERE idproj = id_project AND id_user = idusert)
       AND EXISTS(SELECT *
                  FROM tb_team
                  WHERE idproj = id_project AND
                        iduseralvo = id_user)
    THEN
      DELETE FROM tb_team
      WHERE idproj = id_project AND
            id_user = iduseralvo
      RETURNING 200
        INTO
          vStatus;
      RETURN QUERY
      SELECT vStatus;
    ELSE
      RETURN QUERY
      SELECT 404;
    END IF;
  ELSE
    RETURN QUERY
    SELECT 401;
  END IF;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION changePermissionMember(pIdProject INTEGER, pIdUserTarget INTEGER, permission BOOLEAN)
  RETURNS TABLE(
    status INTEGER
  ) AS $$
BEGIN
  IF EXISTS(SELECT *
            FROM tb_team
            WHERE id_project = pIdProject AND
                  id_user = pIdUserTarget) AND permission = TRUE
  THEN

    UPDATE tb_team
    SET permissions = NOT permissions
    WHERE id_project = pIdProject AND
          id_user = pIdUserTarget;
    RETURN QUERY
    SELECT 1;
  END IF;
  RETURN QUERY
  SELECT 0;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION defaultBlocks(pIdProject INTEGER)
  RETURNS BOOLEAN AS $$
BEGIN
  IF EXISTS(SELECT id_project
            FROM tb_projects
            WHERE id_project = pIdProject)
  THEN
    INSERT INTO tb_blocks (name_blocks, project_owner)
    VALUES ('A fazer', pIdProject),
      ('Fazendo', pIdProject),
      ('ConcluÃ­do', pIdProject);
    RETURN TRUE;
  END IF;
  RETURN FALSE;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION newblocks(nameq CHARACTER VARYING, idproj INTEGER)
  RETURNS BOOLEAN AS $$
BEGIN
  IF EXISTS(SELECT *
            FROM tb_projects
            WHERE id_project = idproj)
  THEN
    INSERT INTO tb_blocks (name_blocks, project_owner) VALUES (nameq, idproj);
    RETURN TRUE;
  END IF;
  RETURN FALSE;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION changeBlockName(pNewName CHARACTER VARYING, pIdBlock INTEGER)
  RETURNS BOOLEAN AS $$
BEGIN
  IF EXISTS(SELECT *
            FROM tb_blocks
            WHERE id_blocks = pIdBlock)
  THEN
    UPDATE tb_blocks
    SET name_blocks = pNewName
    WHERE id_blocks = pIdBlock;
    RETURN TRUE;
  END IF;
  RETURN FALSE;
END;
$$
LANGUAGE plpgsql;

--INSERT INTO tb_team(id_project,id_user,permissions)values(73,31,2),(73,32,2);

--SELECT * FROM searchblock(73)

CREATE OR REPLACE FUNCTION searchblock(projectOwner INTEGER)
  RETURNS TABLE(
    idBlock   INTEGER,
    nameBlock VARCHAR(50),
    tasks     JSON
  ) AS $$
DECLARE
  vIdBlocks INTEGER [];
BEGIN


  vIdBlocks := ARRAY(SELECT id_blocks
                     FROM tb_blocks
                     WHERE project_owner = projectOwner);

  IF vIdBlocks IS NOT NULL
  THEN
    RETURN QUERY
    SELECT
      tb.id_blocks,
      tb.name_blocks,
      (SELECT COALESCE(json_agg(TasksJson), '[]')
       FROM (SELECT
               tt.id_task,
               tt.name_task,
               tt.final_date
             FROM tb_tasks tt
             WHERE tt.id_block = tb.id_blocks) AS TasksJson
      ) tasks
    FROM tb_blocks tb
    WHERE tb.id_blocks = ANY (vIdBlocks);
  END IF;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION deleteBlock(pIdBlock INTEGER)
  RETURNS BOOLEAN AS $$
BEGIN
  IF EXISTS(SELECT *
            FROM tb_blocks
            WHERE id_blocks = pIdBlock)
  THEN
    DELETE FROM tb_tasks
    WHERE id_block = pIdBlock;
    DELETE FROM tb_blocks
    WHERE id_blocks = pIdBlock;
    RETURN TRUE;
  END IF;
  RETURN FALSE;
END;
$$
LANGUAGE plpgsql;

--SELECT * FROM newtasks('joao','21/09/2017',2)

--SELECT * FROM getLastPosition(2)

CREATE OR REPLACE FUNCTION getLastPosition(pIdBlock INTEGER)
  RETURNS TABLE(
    "position" INTEGER
  ) AS $$
DECLARE
  reg           tb_tasks%ROWTYPE;
  vLastPosition INTEGER := 0;
BEGIN
  IF EXISTS(SELECT *
            FROM tb_blocks
            WHERE id_blocks = pIdBlock)
  THEN
    RAISE NOTICE '%', vLastPosition;

    FOR reg IN
    SELECT l.position
    FROM tb_tasks l
    LOOP
      RAISE NOTICE 'ANTES %', vLastPosition;


      IF (SELECT l.position
          FROM tb_tasks l
          WHERE l.position > vLastPosition
          LIMIT 1) IS NOT NULL
      THEN
        SELECT l.position
        INTO vLastPosition
        FROM tb_tasks l
        WHERE l.position > vLastPosition;
      END IF;
      RAISE NOTICE 'DEPOIS %', vLastPosition;
    END LOOP;
  END IF;

  RETURN QUERY
  SELECT vLastPosition;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION newtasks(nametask CHARACTER VARYING, attachment CHARACTER VARYING, date TIMESTAMP,
                                    descrip  TEXT,
                                    idblock  INTEGER)
  RETURNS TABLE(
    idTask       INTEGER,
    nameTaskR    VARCHAR(20),
    dateR        TIMESTAMP,
    description  TEXT,
    idBlockOwner INTEGER
  ) AS $$
DECLARE
  vIdTask     INTEGER;
  vNameTask   VARCHAR(20);
  vDate       TIMESTAMP;
  vDescript   TEXT;
  vBlockOwner INTEGER;

BEGIN
  IF EXISTS(SELECT *
            FROM tb_blocks
            WHERE id_blocks = idblock)
  THEN
    INSERT INTO tb_tasks (name_task, final_date, description, id_block) VALUES (nametask, date, descrip, idblock)
    RETURNING id_task, name_task, final_date, descrip, id_block
      INTO vIdTask, vNameTask, vDate, vDescript, vBlockOwner;
    RETURN QUERY
    SELECT
      vIdTask,
      vNameTask,
      vDate,
      vDescript,
      vBlockOwner;
  END IF;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION changeTask(pIdTask INTEGER, pNameTask CHARACTER VARYING, pDate TIMESTAMP, pDescription TEXT)
  RETURNS BOOLEAN AS $$
BEGIN
  IF EXISTS(SELECT *
            FROM tb_tasks
            WHERE id_task = pIdTask)
  THEN
    UPDATE tb_tasks
    SET name_task = pNameTask,
      final_date  = pDate,
      description = pDescription
    WHERE id_task = pIdTask;
    RETURN TRUE;
  END IF;
  RETURN FALSE;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION moveTask(pIdTask INTEGER, pIdBlock INTEGER)
  RETURNS BOOLEAN AS $$
BEGIN
  IF EXISTS(SELECT *
            FROM tb_tasks
            WHERE id_task = pIdTask) AND EXISTS(SELECT *
                                                FROM tb_blocks
                                                WHERE id_blocks = pIdBlock)
  THEN
    UPDATE tb_tasks
    SET id_block = pIdBlock
    WHERE id_task = pIdTask;
    RETURN TRUE;
  END IF;
  RETURN FALSE;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION showContentTask(pIdTask INTEGER)
  RETURNS TABLE(
    nameTask    VARCHAR(50),
    attachment  VARCHAR(50),
    finalDate   TIMESTAMP,
    description TEXT,
    team        JSON,
    comments    JSON,
    checklists  JSON
  ) AS $$
BEGIN
  IF EXISTS(SELECT *
            FROM tb_tasks
            WHERE id_task = pIdTask)
  THEN
    RETURN QUERY
    SELECT
      l.name_task,
      l.attachment,
      l.final_date,
      l.description,
      (SELECT coalesce(json_agg(teamTask), '[]')
       FROM (SELECT id_user
             FROM tb_team_tasks
             WHERE id_task = pIdTask) AS teamTask),

      (SELECT coalesce(json_agg(jsonComments), '[]')
       FROM (SELECT
               l.id_comment,
               l.comment
             FROM tb_comments l
             WHERE l.id_task = pIdTask) AS jsonComments),

      (SELECT coalesce(json_agg(jsonChecklist), '[]')
       FROM (SELECT
               id_checklist,
               name_checklist,
               checked
             FROM tb_checklist_tasks
             WHERE id_task = pIdTask) AS jsonChecklist)
    FROM tb_tasks l
    WHERE l.id_task = pIdTask;

  END IF;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION buildAttachment(path CHARACTER VARYING, idtask INTEGER)
  RETURNS BOOLEAN AS $$
BEGIN
  IF EXISTS(SELECT *
            FROM tb_tasks
            WHERE id_task = idtask)
  THEN
    UPDATE tb_tasks
    SET attachment = path
    WHERE id_task = idtask;
    RETURN TRUE;
  END IF;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION getPathAttachment(pIdTask INTEGER)
  RETURNS TABLE(
    path VARCHAR(20)
  ) AS $$
BEGIN
  IF EXISTS(SELECT *
            FROM tb_tasks
            WHERE id_task = pIdTask)
  THEN
    RETURN QUERY
    SELECT attachment
    FROM tb_tasks
    WHERE id_task = pIdTask;
  END IF;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION removePathAttachment(pIdTask INTEGER)
  RETURNS BOOLEAN AS $$
BEGIN
  IF EXISTS(SELECT *
            FROM tb_tasks
            WHERE id_task = pIdTask)
  THEN
    UPDATE tb_tasks
    SET attachment = NULL
    WHERE id_task = pIdTask;
    RETURN TRUE;
  END IF;
  RETURN FALSE;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION buildChecklist(pIdTask INTEGER, pChecklist JSON)
  RETURNS BOOLEAN AS $$
BEGIN
  IF EXISTS(SELECT *
            FROM tb_tasks
            WHERE id_task = pIdTask)
  THEN
    INSERT INTO tb_checklist_tasks (name_checklist, id_task, checked)
      SELECT
        "namechecklist",
        "idTask",
        checked
      FROM json_to_recordset(pChecklist)
        AS x(
           "namechecklist" VARCHAR(20),
           "idTask" INTEGER,
           checked BOOLEAN
           );
    RETURN TRUE;
  END IF;
  RETURN FALSE;
END;
$$
LANGUAGE plpgsql;

--SELECT * FROM searchUsers('joao',107);

CREATE OR REPLACE FUNCTION searchusers(puser CHARACTER VARYING, idproject INTEGER)
  RETURNS TABLE(
    iduser   INTEGER,
    nameuser CHARACTER VARYING,
    username CHARACTER VARYING,
    imguser  CHARACTER VARYING
  )
AS $$
DECLARE
  vIdUser   INTEGER [];
  reg       tb_team%ROWTYPE;
  vIdUnique INTEGER;
BEGIN
  IF EXISTS(SELECT *
            FROM tb_login
            WHERE tb_login.username LIKE puser OR tb_login.email LIKE puser OR tb_login.name LIKE puser)
  THEN
    vIdUser :=  ARRAY(SELECT id_user
                      FROM tb_login
                      WHERE tb_login.username LIKE puser OR tb_login.email LIKE puser OR tb_login.name LIKE puser);
    vIdUnique := (SELECT id_user
                  FROM tb_login
                  WHERE tb_login.username LIKE puser OR tb_login.email LIKE puser OR tb_login.name LIKE puser);

    FOR reg IN
    SELECT id_user
    FROM tb_team
    WHERE id_user = ANY (vIdUser)
    LOOP
      vIdUser = array_remove(vIdUser, (SELECT id_user
                                       FROM tb_team
                                       WHERE id_user = ANY (vIdUser) AND id_project = idproject
                                       LIMIT 1));
    END LOOP;
    RETURN QUERY
    SELECT
      tb_login.id_user,
      name,
      tb_login.username,
      profile_img
    FROM tb_login
    WHERE tb_login.id_user = ANY (vIdUser)
    LIMIT 10;
  END IF;
  IF EXISTS(SELECT *
            FROM tb_login
            WHERE tb_login.username ILIKE '%' || pUser || '%' OR
                  tb_login.email ILIKE '%' || pUser || '%' OR
                  tb_login.name ILIKE '%' || pUser || '%')
  THEN
    vIdUser :=  ARRAY(SELECT id_user
                      FROM tb_login
                      WHERE tb_login.username ILIKE '%' || pUser || '%' OR
                            email ILIKE '%' || pUser || '%' OR
                            name ILIKE '%' || pUser || '%');

    IF vIdUnique = ANY (vIdUser)
    THEN
      vIdUser := array_remove(vIdUser, (SELECT id_user
                                        FROM tb_login
                                        WHERE tb_login.username LIKE puser OR tb_login.email LIKE puser OR
                                              tb_login.name LIKE puser));
    END IF;

    FOR reg IN
    SELECT id_user
    FROM tb_team
    WHERE id_user = ANY (vIdUser)
    LOOP
      vIdUser = array_remove(vIdUser, (SELECT id_user
                                       FROM tb_team
                                       WHERE id_user = ANY (vIdUser) AND id_project = idproject
                                       LIMIT 1));
    END LOOP;

    RETURN QUERY
    SELECT
      tb_login.id_user,
      name,
      tb_login.username,
      profile_img
    FROM tb_login
    WHERE tb_login.id_user = ANY (vIdUser)
    LIMIT 10;
  END IF;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION insertTeamTasks(users JSON)
  RETURNS BOOLEAN AS $$
BEGIN
  INSERT INTO tb_team_tasks (id_task, id_user)
    SELECT
      idtask,
      iduser
    FROM json_to_recordset(users)
      AS x(
         idtask INTEGER,
         iduser INTEGER
         );
  RETURN TRUE;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION newComment(pIdTask INTEGER, pComment TEXT)
  RETURNS TABLE(
    idComment INTEGER
  ) AS $$
DECLARE
  vIdComment INTEGER;
BEGIN
  IF EXISTS(SELECT *
            FROM tb_tasks
            WHERE id_task = pIdTask)
  THEN
    INSERT INTO tb_comments (id_task, comment) VALUES (pIdTask, pComment)
    RETURNING id_comment
      INTO vIdComment;
    RETURN QUERY
    SELECT vIdComment;
  END IF;
END;
$$
LANGUAGE plpgsql;

--SELECT * FROM changeComment(2, 'joao1234')

CREATE OR REPLACE FUNCTION changeComment(pIdComment INTEGER, pNewComment CHARACTER VARYING)
  RETURNS BOOLEAN AS $$
BEGIN
  IF EXISTS(SELECT *
            FROM tb_comments
            WHERE id_comment = pIdComment)
  THEN
    UPDATE tb_comments
    SET comment = pNewComment
    WHERE id_comment = pIdComment;
    RETURN TRUE;
  END IF;
  RETURN FALSE;
END;
$$
LANGUAGE plpgsql;
